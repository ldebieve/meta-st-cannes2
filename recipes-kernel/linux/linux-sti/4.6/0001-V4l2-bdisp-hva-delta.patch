From 9c129418079fa8666d94ad2faf1b40d63c408dbd Mon Sep 17 00:00:00 2001
From: Christophe Priouzeau <christophe.priouzeau@st.com>
Date: Fri, 9 Sep 2016 10:08:04 +0200
Subject: [PATCH 01/12] V4l2: bdisp, hva, delta

Signed-off-by: Christophe Priouzeau <christophe.priouzeau@st.com>
---
 .../devicetree/bindings/media/st,sti-hva.txt       |   24 +
 drivers/media/platform/Kconfig                     |   13 +
 drivers/media/platform/Makefile                    |    1 +
 drivers/media/platform/sti/bdisp/bdisp-v4l2.c      |    3 +
 drivers/media/platform/sti/hva/Makefile            |    2 +
 drivers/media/platform/sti/hva/hva-h264.c          | 1096 +++++++++++++
 drivers/media/platform/sti/hva/hva-hw.c            |  511 +++++++
 drivers/media/platform/sti/hva/hva-hw.h            |   73 +
 drivers/media/platform/sti/hva/hva-mem.c           |   63 +
 drivers/media/platform/sti/hva/hva-mem.h           |   19 +
 drivers/media/platform/sti/hva/hva-v4l2.c          | 1610 ++++++++++++++++++++
 drivers/media/platform/sti/hva/hva.h               |  454 ++++++
 12 files changed, 3869 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/media/st,sti-hva.txt
 create mode 100644 drivers/media/platform/sti/hva/Makefile
 create mode 100644 drivers/media/platform/sti/hva/hva-h264.c
 create mode 100644 drivers/media/platform/sti/hva/hva-hw.c
 create mode 100644 drivers/media/platform/sti/hva/hva-hw.h
 create mode 100644 drivers/media/platform/sti/hva/hva-mem.c
 create mode 100644 drivers/media/platform/sti/hva/hva-mem.h
 create mode 100644 drivers/media/platform/sti/hva/hva-v4l2.c
 create mode 100644 drivers/media/platform/sti/hva/hva.h

diff --git a/Documentation/devicetree/bindings/media/st,sti-hva.txt b/Documentation/devicetree/bindings/media/st,sti-hva.txt
new file mode 100644
index 0000000..d1030bb
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/st,sti-hva.txt
@@ -0,0 +1,24 @@
+hva: multi-format video encoder for STMicroelectronics SoC.
+
+Required properties:
+- compatible: should be "st,sti-hva".
+- reg: HVA physical address location and length, esram address location and
+  length.
+- reg-names: names of the registers listed in registers property in the same
+  order.
+- interrupts: HVA interrupt number.
+- clocks: from common clock binding: handle hardware IP needed clocks, the
+  number of clocks may depend on the SoC type.
+  See ../clock/clock-bindings.txt for details.
+- clock-names: names of the clocks listed in clocks property in the same order.
+
+Example:
+	hva@8c85000{
+		compatible = "st,sti-hva";
+		reg = <0x8c85000 0x400>, <0x6000000 0x40000>;
+		reg-names = "hva_registers", "hva_esram";
+		interrupts = <GIC_SPI 58 IRQ_TYPE_NONE>,
+			     <GIC_SPI 59 IRQ_TYPE_NONE>;
+		clock-names = "clk_hva";
+		clocks = <&clk_s_c0_flexgen CLK_HVA>;
+	};
diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 201f5c2..5bbdedf 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -226,6 +226,19 @@ config VIDEO_STI_BDISP
 	help
 	  This v4l2 mem2mem driver is a 2D blitter for STMicroelectronics SoC.
 
+config VIDEO_STI_HVA
+	tristate "STMicroelectronics STiH41x HVA multi-format video encoder V4L2 driver"
+	depends on VIDEO_DEV && VIDEO_V4L2
+	depends on ARCH_STI || COMPILE_TEST
+	select VIDEOBUF2_DMA_CONTIG
+	help
+	  This V4L2 driver enables HVA multi-format video encoder of
+	  STMicroelectronics SoC STiH41x series, allowing hardware encoding of raw
+	  uncompressed formats in various compressed video bitstreams format.
+
+	  To compile this driver as a module, choose M here:
+	  the module will be called hva.
+
 config VIDEO_SH_VEU
 	tristate "SuperH VEU mem2mem video processing driver"
 	depends on VIDEO_DEV && VIDEO_V4L2 && HAS_DMA
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index bbb7bd1..f715cef 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -36,6 +36,7 @@ obj-$(CONFIG_VIDEO_SAMSUNG_S5P_G2D)	+= s5p-g2d/
 obj-$(CONFIG_VIDEO_SAMSUNG_EXYNOS_GSC)	+= exynos-gsc/
 
 obj-$(CONFIG_VIDEO_STI_BDISP)		+= sti/bdisp/
+obj-$(CONFIG_VIDEO_STI_HVA)		+= sti/hva/
 obj-$(CONFIG_DVB_C8SECTPFE)		+= sti/c8sectpfe/
 
 obj-$(CONFIG_BLACKFIN)                  += blackfin/
diff --git a/drivers/media/platform/sti/bdisp/bdisp-v4l2.c b/drivers/media/platform/sti/bdisp/bdisp-v4l2.c
index d12a419..3555334 100644
--- a/drivers/media/platform/sti/bdisp/bdisp-v4l2.c
+++ b/drivers/media/platform/sti/bdisp/bdisp-v4l2.c
@@ -554,6 +554,9 @@ static int queue_init(void *priv,
 	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	src_vq->lock = &ctx->bdisp_dev->lock;
 
+	/* Temporary allow usage of bytesused = 0 */
+	src_vq->allow_zero_bytesused = 1;
+
 	ret = vb2_queue_init(src_vq);
 	if (ret)
 		return ret;
diff --git a/drivers/media/platform/sti/hva/Makefile b/drivers/media/platform/sti/hva/Makefile
new file mode 100644
index 0000000..495894b
--- /dev/null
+++ b/drivers/media/platform/sti/hva/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_VIDEO_STI_HVA) := hva.o
+hva-y := hva-v4l2.o hva-hw.o hva-mem.o hva-h264.o
diff --git a/drivers/media/platform/sti/hva/hva-h264.c b/drivers/media/platform/sti/hva/hva-h264.c
new file mode 100644
index 0000000..b9a3d2d
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-h264.c
@@ -0,0 +1,1096 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include "hva.h"
+#include "hva-hw.h"
+#include "hva-mem.h"
+
+#define MAX_SPS_PPS_SIZE 128
+
+#define BITSTREAM_OFFSET_MASK 0x7F
+
+/* video max size*/
+#define H264_MAX_SIZE_W 1920
+#define H264_MAX_SIZE_H 1920
+
+/* macroBlocs number (width & height) */
+#define MB_W(w) ((w + 0xF)  / 0x10)
+#define MB_H(h) ((h + 0xF)  / 0x10)
+
+/* formula to get temporal or spatial data size */
+#define DATA_SIZE(w, h) (MB_W(w) * MB_H(h) * 16)
+
+#define SEARCH_WINDOW_BUFFER_MAX_SIZE(w) ((4 * MB_W(w) + 42) * 256 * 3 / 2)
+#define CABAC_CONTEXT_BUFFER_MAX_SIZE(w) (MB_W(w) * 16)
+#define CTX_MB_BUFFER_MAX_SIZE(w) (MB_W(w) * 16 * 8)
+#define SLICE_HEADER_SIZE (4 * 16)
+#define BRC_DATA_SIZE (5 * 16)
+
+/* source buffer copy in YUV 420 MB-tiled format with size=16*256*3/2 */
+#define CURRENT_WINDOW_BUFFER_MAX_SIZE (16 * 256 * 3 / 2)
+
+/*
+ * 4 lines of pixels (in Luma, Chroma blue and Chroma red) of top MB
+ * for deblocking with size=4*16*MBx*2
+ */
+#define LOCAL_RECONSTRUCTED_BUFFER_MAX_SIZE(w) (4 * 16 * MB_W(w) * 2)
+
+/* factor for bitrate and cpb buffer size max values if profile >= high */
+#define H264_FACTOR_HIGH 1200
+
+/* factor for bitrate and cpb buffer size max values if profile < high */
+#define H264_FACTOR_BASELINE 1000
+
+/* number of bytes for NALU_TYPE_FILLER_DATA header and footer */
+#define H264_FILLER_DATA_SIZE 6
+
+struct h264_profile {
+	enum v4l2_mpeg_video_h264_level level;
+	u32 max_mb_per_seconds;
+	u32 max_frame_size;
+	u32 max_bitrate;
+	u32 max_cpb_size;
+	u32 min_comp_ratio;
+};
+
+static const struct h264_profile h264_infos_list[] = {
+	{V4L2_MPEG_VIDEO_H264_LEVEL_1_0, 1485, 99, 64, 175, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_1B, 1485, 99, 128, 350, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_1_1, 3000, 396, 192, 500, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_1_2, 6000, 396, 384, 1000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_1_3, 11880, 396, 768, 2000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_2_0, 11880, 396, 2000, 2000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_2_1, 19800, 792, 4000, 4000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_2_2, 20250, 1620, 4000, 4000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_3_0, 40500, 1620, 10000, 10000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_3_1, 108000, 3600, 14000, 14000, 4},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_3_2, 216000, 5120, 20000, 20000, 4},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_4_0, 245760, 8192, 20000, 25000, 4},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_4_1, 245760, 8192, 50000, 62500, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_4_2, 522240, 8704, 50000, 62500, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_5_0, 589824, 22080, 135000, 135000, 2},
+	{V4L2_MPEG_VIDEO_H264_LEVEL_5_1, 983040, 36864, 240000, 240000, 2}
+};
+
+enum hva_brc_type {
+	BRC_TYPE_NONE = 0,
+	BRC_TYPE_CBR = 1,
+	BRC_TYPE_VBR = 2,
+	BRC_TYPE_VBR_LOW_DELAY = 3
+};
+
+enum hva_entropy_coding_mode {
+	CAVLC = 0,
+	CABAC = 1
+};
+
+enum hva_picture_coding_type {
+	PICTURE_CODING_TYPE_I = 0,
+	PICTURE_CODING_TYPE_P = 1,
+	PICTURE_CODING_TYPE_B = 2
+};
+
+enum hva_h264_sampling_mode {
+	SAMPLING_MODE_NV12 = 0,
+	SAMPLING_MODE_UYVY = 1,
+	SAMPLING_MODE_RGB3 = 3,
+	SAMPLING_MODE_XRGB4 = 4,
+	SAMPLING_MODE_NV21 = 8,
+	SAMPLING_MODE_VYUY = 9,
+	SAMPLING_MODE_BGR3 = 11,
+	SAMPLING_MODE_XBGR4 = 12,
+	SAMPLING_MODE_RGBX4 = 20,
+	SAMPLING_MODE_BGRX4 = 28
+};
+
+enum hva_h264_nalu_type {
+	NALU_TYPE_UNKNOWN = 0,
+	NALU_TYPE_SLICE = 1,
+	NALU_TYPE_SLICE_DPA = 2,
+	NALU_TYPE_SLICE_DPB = 3,
+	NALU_TYPE_SLICE_DPC = 4,
+	NALU_TYPE_SLICE_IDR = 5,
+	NALU_TYPE_SEI = 6,
+	NALU_TYPE_SPS = 7,
+	NALU_TYPE_PPS = 8,
+	NALU_TYPE_AU_DELIMITER = 9,
+	NALU_TYPE_SEQ_END = 10,
+	NALU_TYPE_STREAM_END = 11,
+	NALU_TYPE_FILLER_DATA = 12,
+	NALU_TYPE_SPS_EXT = 13,
+	NALU_TYPE_PREFIX_UNIT = 14,
+	NALU_TYPE_SUBSET_SPS = 15,
+	NALU_TYPE_SLICE_AUX = 19,
+	NALU_TYPE_SLICE_EXT = 20
+};
+
+enum hva_h264_sei_payload_type {
+	SEI_BUFFERING_PERIOD = 0,
+	SEI_PICTURE_TIMING = 1,
+	SEI_STEREO_VIDEO_INFO = 21,
+	SEI_FRAME_PACKING_ARRANGEMENT = 45
+};
+
+/**
+ * stereo Video Info struct
+ */
+struct hva_h264_stereo_video_sei {
+	u8 field_views_flag;
+	u8 top_field_is_left_view_flag;
+	u8 current_frame_is_left_view_flag;
+	u8 next_frame_is_second_view_flag;
+	u8 left_view_self_contained_flag;
+	u8 right_view_self_contained_flag;
+};
+
+/**
+ * @frame_width: width in pixels of the buffer containing the input frame
+ * @frame_height: height in pixels of the buffer containing the input frame
+ * @frame_num: the parameter to be written in the slice header
+ * @picture_coding_type: type I, P or B
+ * @pic_order_cnt_type: POC mode, as defined in H264 std : can be 0,1,2
+ * @first_picture_in_sequence: flag telling to encoder that this is the
+ *			       first picture in a video sequence.
+ *			       Used for VBR
+ * @slice_size_type: 0 = no constraint to close the slice
+ *		     1= a slice is closed as soon as the slice_mb_size limit
+ *			is reached
+ *		     2= a slice is closed as soon as the slice_byte_size limit
+ *			is reached
+ *		     3= a slice is closed as soon as either the slice_byte_size
+ *			limit or the slice_mb_size limit is reached
+ * @slice_mb_size: defines the slice size in number of macroblocks
+ *		   (used when slice_size_type=1 or slice_size_type=3)
+ * @ir_param_option: defines the number of macroblocks per frame to be
+ *		     refreshed by AIR algorithm OR the refresh period
+ *		     by CIR algorithm
+ * @intra_refresh_type: enables the adaptive intra refresh algorithm.
+ *			Disable=0 / Adaptative=1 and Cycle=2 as intra refresh
+ * @use_constrained_intra_flag: constrained_intra_pred_flag from PPS
+ * @transform_mode: controls the use of 4x4/8x8 transform mode
+ * @disable_deblocking_filter_idc:
+ *		     0: specifies that all luma and chroma block edges of
+ *			the slice are filtered.
+ *		     1: specifies that deblocking is disabled for all block
+ *			edges of the slice.
+ *		     2: specifies that all luma and chroma block edges of
+ *			the slice are filtered with exception of the block edges
+ *			that coincide with slice boundaries
+ * @slice_alpha_c0_offset_div2: to be written in slice header,
+ *				controls deblocking
+ * @slice_beta_offset_div2: to be written in slice header,
+ *			    controls deblocking
+ * @encoder_complexity: encoder complexity control (IME).
+ *		     0 = I_16x16, P_16x16, Full ME Complexity
+ *		     1 = I_16x16, I_NxN, P_16x16, Full ME Complexity
+ *		     2 = I_16x16, I_NXN, P_16x16, P_WxH, Full ME Complexity
+ *		     4 = I_16x16, P_16x16, Reduced ME Complexity
+ *		     5 = I_16x16, I_NxN, P_16x16, Reduced ME Complexity
+ *		     6 = I_16x16, I_NXN, P_16x16, P_WxH, Reduced ME Complexity
+ *  @chroma_qp_index_offset: coming from picture parameter set
+ *			     (PPS see [H.264 STD] 7.4.2.2)
+ *  @entropy_coding_mode: entropy coding mode.
+ *			  0 = CAVLC
+ *			  1 = CABAC
+ * @brc_type: selects the bit-rate control algorithm
+ *		     0 = constant Qp, (no BRC)
+ *		     1 = CBR
+ *		     2 = VBR
+ * @quant: Quantization param used in case of fix QP encoding (no BRC)
+ * @non_VCL_NALU_Size: size of non-VCL NALUs (SPS, PPS, filler),
+ *		       used by BRC
+ * @cpb_buffer_size: size of Coded Picture Buffer, used by BRC
+ * @bit_rate: target bitrate, for BRC
+ * @qp_min: min QP threshold
+ * @qp_max: max QP threshold
+ * @framerate_num: target framerate numerator , used by BRC
+ * @framerate_den: target framerate denomurator , used by BRC
+ * @delay: End-to-End Initial Delay
+ * @strict_HRD_compliancy: flag for HDR compliancy (1)
+ *			   May impact quality encoding
+ * @addr_source_buffer: address of input frame buffer for current frame
+ * @addr_fwd_Ref_Buffer: address of reference frame buffer
+ * @addr_rec_buffer: address of reconstructed frame buffer
+ * @addr_output_bitstream_start: output bitstream start address
+ * @addr_output_bitstream_end: output bitstream end address
+ * @addr_external_sw : address of external search window
+ * @addr_lctx : address of context picture buffer
+ * @addr_local_rec_buffer: address of local reconstructed buffer
+ * @addr_spatial_context: address of spatial context buffer
+ * @bitstream_offset: offset in bits between aligned bitstream start
+ *		      address and first bit to be written by HVA.
+ *		      Range value is [0..63]
+ * @sampling_mode: Input picture format .
+ *		     0: YUV420 semi_planar Interleaved
+ *		     1: YUV422 raster Interleaved
+ * @addr_param_out: address of output parameters structure
+ * @addr_scaling_matrix: address to the coefficient of
+ *			 the inverse scaling matrix
+ * @addr_scaling_matrix_dir: address to the coefficient of
+ *			     the direct scaling matrix
+ * @addr_cabac_context_buffer: address of cabac context buffer
+ * @GmvX: Input information about the horizontal global displacement of
+ *	  the encoded frame versus the previous one
+ * @GmvY: Input information about the vertical global displacement of
+ *	  the encoded frame versus the previous one
+ * @window_width: width in pixels of the window to be encoded inside
+ *		  the input frame
+ * @window_height: width in pixels of the window to be encoded inside
+ *		   the input frame
+ * @window_horizontal_offset: horizontal offset in pels for input window
+ *			      within input frame
+ * @window_vertical_offset: vertical offset in pels for input window
+ *			    within input frame
+ * @addr_roi: Map of QP offset for the Region of Interest algorithm and
+ *	      also used for Error map.
+ *	      Bit 0-6 used for qp offset (value -64 to 63).
+ *	      Bit 7 used to force intra
+ * @addr_slice_header: address to slice header
+ * @slice_header_size_in_bits: size in bits of the Slice header
+ * @slice_header_offset0: Slice header offset where to insert
+ *			  first_Mb_in_slice
+ * @slice_header_offset1: Slice header offset where to insert
+ *			  slice_qp_delta
+ * @slice_header_offset2: Slice header offset where to insert
+ *			  num_MBs_in_slice
+ * @slice_synchro_enable: enable "slice ready" interrupt after each slice
+ * @max_slice_number: Maximum number of slice in a frame
+ *		      (0 is strictly forbidden)
+ * @rgb2_yuv_y_coeff: Four coefficients (C0C1C2C3) to convert from RGB to
+ *		      YUV for the Y component.
+ *		      Y = C0*R + C1*G + C2*B + C3 (C0 is on byte 0)
+ * @rgb2_yuv_u_coeff: four coefficients (C0C1C2C3) to convert from RGB to
+ *		      YUV for the Y component.
+ *		      Y = C0*R + C1*G + C2*B + C3 (C0 is on byte 0)
+ * @rgb2_yuv_v_coeff: Four coefficients (C0C1C2C3) to convert from RGB to
+ *		      YUV for the U (Cb) component.
+ *		      U = C0*R + C1*G + C2*B + C3 (C0 is on byte 0)
+ * @slice_byte_size: maximum slice size in bytes
+ *		     (used when slice_size_type=2 or slice_size_type=3)
+ * @max_air_intra_mb_nb: Maximum number of intra macroblock in a frame
+ *			 for the AIR algorithm
+ * @brc_no_skip: Disable skipping in the Bitrate Controller
+ * @addr_brc_in_out_parameter: address of static buffer for BRC parameters
+ */
+struct hva_h264_td {
+	u16 frame_width;
+	u16 frame_height;
+	u32 frame_num;
+	u16 picture_coding_type;
+	u16 reserved1;
+	u16 pic_order_cnt_type;
+	u16 first_picture_in_sequence;
+	u16 slice_size_type;
+	u16 reserved2;
+	u32 slice_mb_size;
+	u16 ir_param_option;
+	u16 intra_refresh_type;
+	u16 use_constrained_intra_flag;
+	u16 transform_mode;
+	u16 disable_deblocking_filter_idc;
+	s16 slice_alpha_c0_offset_div2;
+	s16 slice_beta_offset_div2;
+	u16 encoder_complexity;
+	s16 chroma_qp_index_offset;
+	u16 entropy_coding_mode;
+	u16 brc_type;
+	u16 quant;
+	u32 non_vcl_nalu_size;
+	u32 cpb_buffer_size;
+	u32 bit_rate;
+	u16 qp_min;
+	u16 qp_max;
+	u16 framerate_num;
+	u16 framerate_den;
+	u16 delay;
+	u16 strict_hrd_compliancy;
+	u32 addr_source_buffer;
+	u32 addr_fwd_ref_buffer;
+	u32 addr_rec_buffer;
+	u32 addr_output_bitstream_start;
+	u32 addr_output_bitstream_end;
+	u32 addr_external_sw;
+	u32 addr_lctx;
+	u32 addr_local_rec_buffer;
+	u32 addr_spatial_context;
+	u16 bitstream_offset;
+	u16 sampling_mode;
+	u32 addr_param_out;
+	u32 addr_scaling_matrix;
+	u32 addr_scaling_matrix_dir;
+	u32 addr_cabac_context_buffer;
+	u32 reserved3;
+	u32 reserved4;
+	s16 gmv_x;
+	s16 gmv_y;
+	u16 window_width;
+	u16 window_height;
+	u16 window_horizontal_offset;
+	u16 window_vertical_offset;
+	u32 addr_roi;
+	u32 addr_slice_header;
+	u16 slice_header_size_in_bits;
+	u16 slice_header_offset0;
+	u16 slice_header_offset1;
+	u16 slice_header_offset2;
+	u32 reserved5;
+	u32 reserved6;
+	u16 reserved7;
+	u16 reserved8;
+	u16 slice_synchro_enable;
+	u16 max_slice_number;
+	u32 rgb2_yuv_y_coeff;
+	u32 rgb2_yuv_u_coeff;
+	u32 rgb2_yuv_v_coeff;
+	u32 slice_byte_size;
+	u16 max_air_intra_mb_nb;
+	u16 brc_no_skip;
+	u32 addr_temporal_context;
+	u32 addr_brc_in_out_parameter;
+};
+
+/**
+ * @ slice_size: slice size
+ * @ slice_start_time: start time
+ * @ slice_stop_time: stop time
+ * @ slice_num: slice number
+ */
+struct hva_h264_slice_po {
+	u32 slice_size;
+	u32 slice_start_time;
+	u32 slice_end_time;
+	u32 slice_num;
+};
+
+/**
+ * @ bitstream_size: bitstream size
+ * @ dct_bitstream_size: dtc bitstream size
+ * @ stuffing_bits: number of stuffing bits inserted by the encoder
+ * @ removal_time: removal time of current frame (nb of ticks 1/framerate)
+ * @ hvc_start_time: hvc start time
+ * @ hvc_stop_time: hvc stop time
+ * @ slice_count: slice count
+ */
+struct hva_h264_po {
+	u32 bitstream_size;
+	u32 dct_bitstream_size;
+	u32 stuffing_bits;
+	u32 removal_time;
+	u32 hvc_start_time;
+	u32 hvc_stop_time;
+	u32 slice_count;
+	u32 reserved0;
+	struct hva_h264_slice_po slice_params[16];
+};
+
+struct hva_h264_task {
+	struct hva_h264_td td;
+	struct hva_h264_po po;
+};
+
+struct hva_h264_ctx {
+	struct hva_buffer *seq_info_buf;
+	struct hva_buffer *ref_frame;
+	struct hva_buffer *rec_frame;
+};
+
+static int hva_h264_fill_slice_header(struct hva_ctx *pctx,
+				      u8 *slice_header_addr,
+				      struct hva_controls *ctrls,
+				      int frame_num,
+				      u16 *header_size,
+				      u16 *header_offset0,
+				      u16 *header_offset1,
+				      u16 *header_offset2)
+{
+	/*
+	 * with this HVA hardware version, part of the slice header is computed
+	 * on host and part by hardware.
+	 * The part of host is precomputed and available through this array.
+	 */
+	struct device *dev = ctx_to_dev(pctx);
+	int  cabac = V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC;
+	const unsigned char slice_header[] = { 0x00, 0x00, 0x00, 0x01,
+					       0x41, 0x34, 0x07, 0x00};
+	int idr_pic_id = frame_num % 2;
+	enum hva_picture_coding_type type;
+	u32 frame_order = frame_num % ctrls->gop_size;
+
+	if (!(frame_num % ctrls->gop_size))
+		type = PICTURE_CODING_TYPE_I;
+	else
+		type = PICTURE_CODING_TYPE_P;
+
+	memcpy(slice_header_addr, slice_header, sizeof(slice_header));
+
+	*header_size = 56;
+	*header_offset0 = 40;
+	*header_offset1 = 13;
+	*header_offset2 = 0;
+
+	if (type == PICTURE_CODING_TYPE_I) {
+		slice_header_addr[4] = 0x65;
+		slice_header_addr[5] = 0x11;
+
+		/* toggle the I frame */
+		if ((frame_num / ctrls->gop_size) % 2) {
+			*header_size += 4;
+			*header_offset1 += 4;
+			slice_header_addr[6] = 0x04;
+			slice_header_addr[7] = 0x70;
+
+		} else {
+			*header_size += 2;
+			*header_offset1 += 2;
+			slice_header_addr[6] = 0x09;
+			slice_header_addr[7] = 0xC0;
+		}
+	} else {
+		if (ctrls->entropy_mode == cabac) {
+			*header_size += 1;
+			*header_offset1 += 1;
+			slice_header_addr[7] = 0x80;
+		}
+		/*
+		 * update slice header with P frame order
+		 * frame order is limited to 16 (coded on 4bits only)
+		 */
+		slice_header_addr[5] += ((frame_order & 0x0C) >> 2);
+		slice_header_addr[6] += ((frame_order & 0x03) << 6);
+	}
+
+	dev_dbg(dev,
+		"%s   %s slice header order %d idrPicId %d header size %d\n",
+		pctx->name, __func__, frame_order, idr_pic_id, *header_size);
+	return 0;
+}
+
+static int hva_h264_fill_data_nal(struct hva_ctx *pctx,
+				  unsigned int stuffing_bytes, u8 *addr,
+				  unsigned int *size)
+{
+	struct device *dev = ctx_to_dev(pctx);
+	const u8 start[] = { 0x00, 0x00, 0x00, 0x01 };
+	unsigned int size_stream;
+
+	dev_dbg(dev, "%s   %s stuffing bytes %d\n", pctx->name, __func__,
+		stuffing_bytes);
+
+	size_stream = pctx->streaminfo.width * pctx->streaminfo.height;
+	if ((*size + stuffing_bytes + H264_FILLER_DATA_SIZE) > size_stream) {
+		dev_dbg(dev, "%s   %s too many stuffing bytes %d\n",
+			pctx->name, __func__, stuffing_bytes);
+		return 0;
+	}
+
+	/* start code */
+	memcpy(addr + *size, start, sizeof(start));
+	*size += sizeof(start);
+
+	/* nal_unit_type */
+	addr[*size] = NALU_TYPE_FILLER_DATA;
+	*size += 1;
+
+	memset(addr + *size, 0xff, stuffing_bytes);
+	*size += stuffing_bytes;
+
+	addr[*size] = 0x80;
+	*size += 1;
+
+	return 0;
+}
+
+static int hva_h264_fill_sei_nal(struct hva_ctx *pctx,
+				 enum hva_h264_sei_payload_type type,
+				 u8 *addr, u32 *size)
+{
+	struct device *dev = ctx_to_dev(pctx);
+	const u8 start[] = { 0x00, 0x00, 0x00, 0x01 };
+	struct hva_h264_stereo_video_sei info;
+	u8 offset = 7;
+	u8 msg = 0;
+
+	/* start code */
+	memcpy(addr + *size, start, sizeof(start));
+	*size += sizeof(start);
+
+	/* nal_unit_type */
+	addr[*size] = NALU_TYPE_SEI;
+	*size += 1;
+
+	/* payload type */
+	addr[*size] = type;
+	*size += 1;
+
+	switch (type) {
+	case SEI_STEREO_VIDEO_INFO:
+		memset(&info, 0, sizeof(info));
+
+		/* set to top/bottom frame packing arrangement */
+		info.field_views_flag = 1;
+		info.top_field_is_left_view_flag = 1;
+
+		/* payload size */
+		addr[*size] = 1;
+		*size += 1;
+
+		/* payload */
+		msg = info.field_views_flag << offset--;
+
+		if (info.field_views_flag) {
+			msg |= info.top_field_is_left_view_flag <<
+			       offset--;
+		} else {
+			msg |= info.current_frame_is_left_view_flag <<
+			       offset--;
+			msg |= info.next_frame_is_second_view_flag <<
+			       offset--;
+		}
+		msg |= info.left_view_self_contained_flag << offset--;
+		msg |= info.right_view_self_contained_flag << offset--;
+
+		addr[*size] = msg;
+		*size += 1;
+
+		addr[*size] = 0x80;
+		*size += 1;
+
+		return 0;
+	case SEI_BUFFERING_PERIOD:
+	case SEI_PICTURE_TIMING:
+	case SEI_FRAME_PACKING_ARRANGEMENT:
+	default:
+		dev_err(dev, " %s   sei nal type not supported %d\n",
+			pctx->name, type);
+		return -EINVAL;
+	}
+}
+
+static int hva_h264_prepare_task(struct hva_ctx *pctx,
+				 struct hva_buffer *task,
+				 struct hva_frame *frame,
+				 struct hva_stream *stream)
+{
+	struct hva_device *hva = ctx_to_hdev(pctx);
+	struct hva_h264_task *video_task = task->vaddr;
+	struct hva_h264_td *td = &video_task->td;
+	struct hva_h264_ctx *ctx = (struct hva_h264_ctx *)pctx->priv;
+	struct device *dev = ctx_to_dev(pctx);
+	struct hva_buffer *seq_info_buf = ctx->seq_info_buf;
+	struct hva_buffer *fwd_ref_frame = ctx->ref_frame;
+	struct hva_buffer *loc_rec_frame = ctx->rec_frame;
+	struct hva_controls *ctrls = &pctx->ctrls;
+	struct v4l2_fract *time_per_frame = &pctx->time_per_frame;
+	int cavlc =  V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC;
+	u32 frame_num = pctx->stream_num;
+	u32 addr_esram = hva->esram_addr;
+	enum v4l2_mpeg_video_h264_level level;
+	dma_addr_t paddr = 0;
+	u8 *slice_header_vaddr;
+	u32 frame_width = pctx->frameinfo.frame_width;
+	u32 frame_height = pctx->frameinfo.frame_height;
+	u32 max_cpb_buffer_size;
+	unsigned int payload = stream->payload;
+	u32 max_bitrate;
+
+	mutex_lock(&hva->protect_mutex);
+
+	/* check width and height parameters */
+	if ((frame_width > max(H264_MAX_SIZE_W, H264_MAX_SIZE_H)) ||
+	    (frame_height > max(H264_MAX_SIZE_W, H264_MAX_SIZE_H))) {
+		dev_err(dev,
+			"%s   width(%d) or height(%d) exceeds limits (%dx%d)\n",
+			pctx->name, frame_width, frame_height,
+			H264_MAX_SIZE_W, H264_MAX_SIZE_H);
+		pctx->frame_errors++;
+		goto err;
+	}
+
+	level = ctrls->level;
+
+	memset(td, 0, sizeof(struct hva_h264_td));
+
+	td->frame_width = frame_width;
+	td->frame_height = frame_height;
+
+	/* set frame alignement */
+	td->window_width =  ALIGN(pctx->frameinfo.width, 16);
+	td->window_height = ALIGN(pctx->frameinfo.height, 16);
+	td->window_horizontal_offset = 0;
+	td->window_vertical_offset = 0;
+
+	td->first_picture_in_sequence = (!frame_num) ? 1 : 0;
+
+	/* pic_order_cnt_type hard coded to '2' as only I & P frames */
+	td->pic_order_cnt_type = 2;
+
+	/* useConstrainedIntraFlag set to false for better coding efficiency */
+	td->use_constrained_intra_flag = false;
+	td->brc_type = (ctrls->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR)
+			? BRC_TYPE_CBR : BRC_TYPE_VBR;
+
+	td->entropy_coding_mode = (ctrls->entropy_mode == cavlc) ? CAVLC :
+				  CABAC;
+
+	/* convert bitrate in bits per seconds */
+	td->bit_rate = ctrls->bitrate * 1000;
+
+	/* set framerate, framerate = 1 n/ time per frame */
+	if (time_per_frame->numerator >= 536) {
+		/*
+		 * due to a hardware bug, framerate denominator can't exceed
+		 * 536 (BRC overflow). Compute nearest framerate
+		 */
+		td->framerate_den = 1;
+		td->framerate_num = (time_per_frame->denominator +
+				    (time_per_frame->numerator >> 1) - 1) /
+				    time_per_frame->numerator;
+
+		/*
+		 * update bitrate to introduce a correction due to
+		 * the new framerate
+		 * new bitrate = (old bitrate * new framerate) / old framerate
+		 */
+		td->bit_rate /= time_per_frame->numerator;
+		td->bit_rate *= time_per_frame->denominator;
+		td->bit_rate /= td->framerate_num;
+	} else {
+		td->framerate_den = time_per_frame->numerator;
+		td->framerate_num = time_per_frame->denominator;
+	}
+
+	/* compute maximum bitrate depending on profile */
+	if (ctrls->profile >= V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)
+		max_bitrate = h264_infos_list[level].max_bitrate *
+			      H264_FACTOR_HIGH;
+	else
+		max_bitrate = h264_infos_list[level].max_bitrate *
+			      H264_FACTOR_BASELINE;
+
+	/* check if bitrate doesn't exceed max size */
+	if (td->bit_rate > max_bitrate) {
+		dev_warn(dev,
+			 "%s   bitrate (%d) larger than level and profile allow, clip to %d\n",
+			 pctx->name, td->bit_rate, max_bitrate);
+		td->bit_rate = max_bitrate;
+	}
+
+	/* convert cpb_buffer_size in bits */
+	td->cpb_buffer_size = ctrls->cpb_size * 1000;
+
+	/* compute maximum cpb buffer size depending on profile */
+	if (ctrls->profile >= V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)
+		max_cpb_buffer_size =
+		    h264_infos_list[level].max_cpb_size * H264_FACTOR_HIGH;
+	else
+		max_cpb_buffer_size =
+		    h264_infos_list[level].max_cpb_size * H264_FACTOR_BASELINE;
+
+	/* check if cpb buffer size doesn't exceed max size */
+	if (td->cpb_buffer_size > max_cpb_buffer_size) {
+		dev_warn(dev,
+			 "%s   cpb size larger than level %d allows, clip to %d\n",
+			pctx->name, td->cpb_buffer_size,
+			max_cpb_buffer_size);
+		td->cpb_buffer_size = max_cpb_buffer_size;
+	}
+
+	/* enable skipping in the Bitrate Controller */
+	td->brc_no_skip = 0;
+
+	/* initial delay */
+	if ((ctrls->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR) &&
+	    td->bit_rate)
+		td->delay = 1000 * (td->cpb_buffer_size / td->bit_rate);
+	else
+		td->delay = 0;
+
+	switch (pctx->frameinfo.fmt.pixelformat) {
+	case V4L2_PIX_FMT_NV12:
+		td->sampling_mode = SAMPLING_MODE_NV12;
+		break;
+	case V4L2_PIX_FMT_NV21:
+		td->sampling_mode = SAMPLING_MODE_NV21;
+		break;
+	case V4L2_PIX_FMT_UYVY:
+		td->sampling_mode = SAMPLING_MODE_UYVY;
+		break;
+	case V4L2_PIX_FMT_VYUY:
+		td->sampling_mode = SAMPLING_MODE_VYUY;
+		break;
+	case V4L2_PIX_FMT_RGB24:
+		td->sampling_mode = SAMPLING_MODE_RGB3;
+		break;
+	case V4L2_PIX_FMT_BGR24:
+		td->sampling_mode = SAMPLING_MODE_BGR3;
+		break;
+	case V4L2_PIX_FMT_RGB32:
+		td->sampling_mode = SAMPLING_MODE_RGBX4;
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		td->sampling_mode = SAMPLING_MODE_BGRX4;
+		break;
+	case V4L2_PIX_FMT_XRGB32:
+		td->sampling_mode = SAMPLING_MODE_XRGB4;
+		break;
+	case V4L2_PIX_FMT_XBGR32:
+		td->sampling_mode = SAMPLING_MODE_XBGR4;
+		break;
+	default:
+		dev_err(dev, "%s   invalid source pixel format\n",
+			pctx->name);
+		pctx->frame_errors++;
+		goto err;
+	}
+
+	/*
+	 * fill matrix color converter (RGB to YUV)
+	 * Y = 0,299 R + 0,587 G + 0,114 B
+	 * Cb = -0,1687 R -0,3313 G + 0,5 B + 128
+	 * Cr = 0,5 R - 0,4187 G - 0,0813 B + 128
+	 */
+	td->rgb2_yuv_y_coeff = 0x12031008;
+	td->rgb2_yuv_u_coeff = 0x800EF7FB;
+	td->rgb2_yuv_v_coeff = 0x80FEF40E;
+
+	/* enable/disable transform mode */
+	td->transform_mode = ctrls->dct8x8;
+
+	/* encoder complexity fix to 2, ENCODE_I_16x16_I_NxN_P_16x16_P_WxH */
+	td->encoder_complexity = 2;
+
+	/* quant fix to 28, default VBR value */
+	td->quant = 28;
+
+	if (td->framerate_den == 0) {
+		dev_err(dev, "%s   invalid framerate\n", pctx->name);
+		pctx->frame_errors++;
+		goto err;
+	}
+
+	/* if automatic framerate, deactivate bitrate controller */
+	if (td->framerate_num == 0)
+		td->brc_type = 0;
+
+	/* compliancy fix to true */
+	td->strict_hrd_compliancy = 1;
+
+	/* set minimum & maximum quantizers */
+	td->qp_min = clamp_val(ctrls->qpmin, 0, 51);
+	td->qp_max = clamp_val(ctrls->qpmax, 0, 51);
+
+	td->addr_source_buffer = frame->paddr;
+	td->addr_fwd_ref_buffer = fwd_ref_frame->paddr;
+	td->addr_rec_buffer = loc_rec_frame->paddr;
+
+	td->addr_output_bitstream_end = (u32)stream->paddr +
+					vb2_plane_size(&stream->v4l2.vb2_buf,
+						       0);
+
+	td->addr_output_bitstream_start = (u32)stream->paddr;
+	td->bitstream_offset = (((u32)stream->paddr & 0xF) << 3) &
+			       BITSTREAM_OFFSET_MASK;
+
+	td->addr_param_out = (u32)task->paddr +
+			     offsetof(struct hva_h264_task, po);
+
+	/* swap spatial and temporal context */
+	if (frame_num % 2) {
+		paddr = seq_info_buf->paddr;
+		td->addr_spatial_context =  ALIGN(paddr, 0x100);
+		paddr = seq_info_buf->paddr + DATA_SIZE(frame_width,
+							frame_height);
+		td->addr_temporal_context = ALIGN(paddr, 0x100);
+	} else {
+		paddr = seq_info_buf->paddr;
+		td->addr_temporal_context = ALIGN(paddr, 0x100);
+		paddr = seq_info_buf->paddr + DATA_SIZE(frame_width,
+							frame_height);
+		td->addr_spatial_context =  ALIGN(paddr, 0x100);
+	}
+
+	paddr = seq_info_buf->paddr + 2 * DATA_SIZE(frame_width, frame_height);
+
+	td->addr_brc_in_out_parameter =  ALIGN(paddr, 0x100);
+
+	paddr = td->addr_brc_in_out_parameter + BRC_DATA_SIZE;
+	td->addr_slice_header =  ALIGN(paddr, 0x100);
+	td->addr_external_sw =  ALIGN(addr_esram, 0x100);
+
+	addr_esram += SEARCH_WINDOW_BUFFER_MAX_SIZE(frame_width);
+	td->addr_local_rec_buffer = ALIGN(addr_esram, 0x100);
+
+	addr_esram += LOCAL_RECONSTRUCTED_BUFFER_MAX_SIZE(frame_width);
+	td->addr_lctx = ALIGN(addr_esram, 0x100);
+
+	addr_esram += CTX_MB_BUFFER_MAX_SIZE(max(frame_width, frame_height));
+	td->addr_cabac_context_buffer = ALIGN(addr_esram, 0x100);
+
+	if (!(frame_num % ctrls->gop_size)) {
+		td->picture_coding_type = PICTURE_CODING_TYPE_I;
+		stream->v4l2.flags |= V4L2_BUF_FLAG_KEYFRAME;
+	} else {
+		td->picture_coding_type = PICTURE_CODING_TYPE_P;
+		stream->v4l2.flags &= ~V4L2_BUF_FLAG_KEYFRAME;
+	}
+
+	/* fill the slice header part */
+	slice_header_vaddr = seq_info_buf->vaddr + (td->addr_slice_header -
+			     seq_info_buf->paddr);
+
+	hva_h264_fill_slice_header(pctx, slice_header_vaddr, ctrls, frame_num,
+				   &td->slice_header_size_in_bits,
+				   &td->slice_header_offset0,
+				   &td->slice_header_offset1,
+				   &td->slice_header_offset2);
+
+	td->chroma_qp_index_offset = 2;
+	td->slice_synchro_enable = 0;
+	td->max_slice_number = 1;
+
+	/*
+	 * check the sps/pps header size for key frame only
+	 * sps/pps header was previously fill by libv4l
+	 * during qbuf of stream buffer
+	 */
+	if ((stream->v4l2.flags == V4L2_BUF_FLAG_KEYFRAME) &&
+	    (payload > MAX_SPS_PPS_SIZE)) {
+		dev_err(dev, "%s   invalid sps/pps size %d\n", pctx->name,
+			payload);
+		pctx->frame_errors++;
+		goto err;
+	}
+
+	if (stream->v4l2.flags != V4L2_BUF_FLAG_KEYFRAME)
+		payload = 0;
+
+	/* add SEI nal (video stereo info) */
+	if (ctrls->sei_fp && hva_h264_fill_sei_nal(pctx, SEI_STEREO_VIDEO_INFO,
+						   (u8 *)stream->vaddr,
+						   &payload)) {
+		dev_err(dev, "%s   fail to get SEI nal\n", pctx->name);
+		pctx->frame_errors++;
+		goto err;
+	}
+
+	/* fill size of non-VCL NAL units (SPS, PPS, filler and SEI) */
+	td->non_vcl_nalu_size = payload * 8;
+
+	/* compute bitstream offset & new start address of bitstream */
+	td->addr_output_bitstream_start += ((payload >> 4) << 4);
+	td->bitstream_offset += (payload - ((payload >> 4) << 4)) * 8;
+
+	stream->payload = payload;
+
+	mutex_unlock(&hva->protect_mutex);
+	return 0;
+
+err:
+	mutex_unlock(&hva->protect_mutex);
+	return -EINVAL;
+}
+
+static unsigned int hva_h264_get_au_size(struct hva_buffer *task)
+{
+	struct hva_h264_task *video_task = task->vaddr;
+	struct hva_h264_po *po = &video_task->po;
+
+	return po->bitstream_size;
+}
+
+static u32 hva_h264_get_stuffing_bytes(struct hva_buffer *task)
+{
+	struct hva_h264_task *video_task = task->vaddr;
+	struct hva_h264_po *po = &video_task->po;
+
+	return po->stuffing_bits >> 3;
+}
+
+/*
+ *              codec ioctls operations
+ */
+
+static int hva_h264_open(struct hva_ctx *pctx)
+{
+	struct device *dev = ctx_to_dev(pctx);
+	struct hva_h264_ctx *ctx = NULL;
+	struct hva_device *hva = ctx_to_hdev(pctx);
+	u32 frame_width = pctx->frameinfo.frame_width;
+	u32 frame_height = pctx->frameinfo.frame_height;
+	u32 size;
+	int ret = 0;
+
+	/* check esram size necessary to encode a frame */
+	size = SEARCH_WINDOW_BUFFER_MAX_SIZE(frame_width) +
+	       LOCAL_RECONSTRUCTED_BUFFER_MAX_SIZE(frame_width) +
+	       CTX_MB_BUFFER_MAX_SIZE(max(frame_width, frame_height)) +
+	       CABAC_CONTEXT_BUFFER_MAX_SIZE(frame_width);
+
+	if (hva->esram_size < size) {
+		dev_err(dev, "%s   not enough esram (max:%d request:%d)\n",
+			pctx->name, hva->esram_size, size);
+		pctx->sys_errors++;
+		return -EINVAL;
+	}
+
+	/* allocate context for codec */
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		ret = -ENOMEM;
+
+	pctx->priv = (void *)ctx;
+
+	/* set info flags for debugfs */
+	pctx->streaminfo.flags |= HVA_STREAMINFO_FLAG_H264;
+
+	return ret;
+}
+
+static int hva_h264_close(struct hva_ctx *pctx)
+{
+	struct hva_h264_ctx *ctx = (struct hva_h264_ctx *)pctx->priv;
+	struct device *dev = ctx_to_dev(pctx);
+
+	if (ctx->seq_info_buf)
+		hva_mem_free(pctx, ctx->seq_info_buf);
+
+	if (ctx->rec_frame)
+		hva_mem_free(pctx, ctx->rec_frame);
+
+	if (ctx->ref_frame)
+		hva_mem_free(pctx, ctx->ref_frame);
+
+	if (pctx->task)
+		hva_mem_free(pctx, pctx->task);
+
+	devm_kfree(dev, ctx);
+
+	return 0;
+}
+
+static int hva_h264_encode(struct hva_ctx *pctx, struct hva_frame *frame,
+			   struct hva_stream *au)
+{
+	struct device *dev = ctx_to_dev(pctx);
+	struct hva_h264_ctx *ctx = (struct hva_h264_ctx *)pctx->priv;
+	struct hva_buffer *tmp_frame;
+	struct hva_buffer *task;
+	u32 width = pctx->frameinfo.frame_width;
+	u32 height = pctx->frameinfo.frame_height;
+	u32 stuffing_bytes = 0;
+	int ret = 0;
+
+	/* allocate sequence info buffer & local frames if needed */
+	if (!ctx->seq_info_buf) {
+		ret = hva_mem_alloc(pctx,
+				    2 * DATA_SIZE(width, height) +
+				    SLICE_HEADER_SIZE +
+				    BRC_DATA_SIZE,
+				    "hva sequence info buffer",
+				    &ctx->seq_info_buf);
+		if (ret || !ctx->seq_info_buf) {
+			dev_err(dev,
+				"%s   no more memory for sequence info buffer\n",
+				pctx->name);
+			pctx->sys_errors++;
+			return -ENOMEM;
+		}
+	}
+
+	if (!ctx->ref_frame) {
+		ret = hva_mem_alloc(pctx,
+				    width * height * 3 / 2,
+				    "hva reference frame", &ctx->ref_frame);
+		if (ret || !ctx->ref_frame) {
+			dev_err(dev, "%s   more memory for reference frame\n",
+				pctx->name);
+			pctx->sys_errors++;
+			return -ENOMEM;
+		}
+	}
+
+	if (!ctx->rec_frame) {
+		ret = hva_mem_alloc(pctx,
+				    width * height * 3 / 2,
+				    "hva reconstructed frame", &ctx->rec_frame);
+		if (ret || !ctx->rec_frame) {
+			dev_err(dev,
+				"%s   no more memory for reconstructed frame\n",
+				pctx->name);
+			pctx->sys_errors++;
+			return -ENOMEM;
+		}
+	}
+
+	/* allocate task descriptor if not already done */
+	if (!pctx->task) {
+		ret = hva_mem_alloc(pctx,
+				    sizeof(struct hva_h264_task),
+				    "hva task descriptor", &pctx->task);
+		if (ret || !pctx->task) {
+			dev_err(dev,
+				"%s   no more memory for task descriptor\n",
+				pctx->name);
+			return -ENOMEM;
+		}
+	}
+
+	/* only one task allocated & used */
+	task = pctx->task;
+
+	ret = hva_h264_prepare_task(pctx, task, frame, au);
+	if (ret)
+		goto err;
+
+	ret = hva_hw_execute_task(pctx, H264_ENC, task);
+	if (ret)
+		goto err;
+
+	pctx->stream_num++;
+	au->payload += hva_h264_get_au_size(task);
+
+	stuffing_bytes = hva_h264_get_stuffing_bytes(task);
+
+	if (stuffing_bytes)
+		hva_h264_fill_data_nal(pctx, stuffing_bytes,
+				       (u8 *)au->vaddr,
+				       &au->payload);
+
+	vb2_set_plane_payload(&au->v4l2.vb2_buf, 0, au->payload);
+
+	/* switch reference & reconstructed frame */
+	tmp_frame = ctx->ref_frame;
+	ctx->ref_frame = ctx->rec_frame;
+	ctx->rec_frame = tmp_frame;
+
+	return 0;
+err:
+	vb2_set_plane_payload(&au->v4l2.vb2_buf, 0, 0);
+	return ret;
+}
+
+const struct hva_encoder nv12h264enc = {
+	.name = "H264(NV12)",
+	.pixelformat = V4L2_PIX_FMT_NV12,
+	.streamformat = V4L2_PIX_FMT_H264,
+	.max_width = H264_MAX_SIZE_W,
+	.max_height = H264_MAX_SIZE_H,
+	.open = hva_h264_open,
+	.close = hva_h264_close,
+	.encode = hva_h264_encode,
+};
+
+const struct hva_encoder nv21h264enc = {
+	.name = "H264(NV21)",
+	.pixelformat = V4L2_PIX_FMT_NV21,
+	.streamformat = V4L2_PIX_FMT_H264,
+	.max_width = H264_MAX_SIZE_W,
+	.max_height = H264_MAX_SIZE_H,
+	.open = hva_h264_open,
+	.close = hva_h264_close,
+	.encode = hva_h264_encode,
+};
diff --git a/drivers/media/platform/sti/hva/hva-hw.c b/drivers/media/platform/sti/hva/hva-hw.c
new file mode 100644
index 0000000..44f2d2a
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-hw.c
@@ -0,0 +1,511 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include <linux/clk.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+
+#include "hva.h"
+#include "hva-hw.h"
+
+/* HVA register offsets */
+#define HVA_HIF_REG_RST                 0x0100U
+#define HVA_HIF_REG_RST_ACK             0x0104U
+#define HVA_HIF_REG_MIF_CFG             0x0108U
+#define HVA_HIF_REG_HEC_MIF_CFG         0x010CU
+#define HVA_HIF_REG_CFL                 0x0110U
+#define HVA_HIF_FIFO_CMD                0x0114U
+#define HVA_HIF_FIFO_STS                0x0118U
+#define HVA_HIF_REG_SFL                 0x011CU
+#define HVA_HIF_REG_IT_ACK              0x0120U
+#define HVA_HIF_REG_ERR_IT_ACK          0x0124U
+#define HVA_HIF_REG_LMI_ERR             0x0128U
+#define HVA_HIF_REG_EMI_ERR             0x012CU
+#define HVA_HIF_REG_HEC_MIF_ERR         0x0130U
+#define HVA_HIF_REG_HEC_STS             0x0134U
+#define HVA_HIF_REG_HVC_STS             0x0138U
+#define HVA_HIF_REG_HJE_STS             0x013CU
+#define HVA_HIF_REG_CNT                 0x0140U
+#define HVA_HIF_REG_HEC_CHKSYN_DIS      0x0144U
+#define HVA_HIF_REG_CLK_GATING          0x0148U
+#define HVA_HIF_REG_VERSION             0x014CU
+#define HVA_HIF_REG_BSM                 0x0150U
+
+/* define value for version id register (HVA_HIF_REG_VERSION) */
+#define VERSION_ID_MASK	0x0000FFFF
+
+/* define values for BSM register (HVA_HIF_REG_BSM) */
+#define BSM_CFG_VAL1	0x0003F000
+#define BSM_CFG_VAL2	0x003F0000
+
+/* define values for memory interface register (HVA_HIF_REG_MIF_CFG) */
+#define MIF_CFG_VAL1	0x04460446
+#define MIF_CFG_VAL2	0x04460806
+#define MIF_CFG_VAL3	0x00000000
+
+/* define value for HEC memory interface register (HVA_HIF_REG_MIF_CFG) */
+#define HEC_MIF_CFG_VAL	0x000000C4
+
+/*  Bits definition for clock gating register (HVA_HIF_REG_CLK_GATING) */
+#define CLK_GATING_HVC	BIT(0)
+#define CLK_GATING_HEC	BIT(1)
+#define CLK_GATING_HJE	BIT(2)
+
+/* fix hva clock rate */
+#define CLK_RATE		300000000
+
+/* fix delay for pmruntime */
+#define AUTOSUSPEND_DELAY_MS	3
+
+static irqreturn_t hva_hw_its_interrupt(int irq, void *data)
+{
+	struct hva_device *hva = data;
+
+	/* read status registers */
+	hva->sts_reg = readl_relaxed(hva->regs + HVA_HIF_FIFO_STS);
+	hva->sfl_reg = readl_relaxed(hva->regs + HVA_HIF_REG_SFL);
+
+	/* acknowledge interruption */
+	writel_relaxed(0x1, hva->regs + HVA_HIF_REG_IT_ACK);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t hva_hw_its_irq_thread(int irq, void *arg)
+{
+	struct hva_device *hva = arg;
+	struct device *dev = hva_to_dev(hva);
+	u32 status = hva->sts_reg & 0xFF;
+	u8 client_id = (hva->sts_reg & 0xFF00) >> 8;
+	struct hva_ctx *ctx = NULL;
+
+	dev_dbg(dev, "%s     %s: status :0x%02x fifo level :0x%02x\n",
+		HVA_PREFIX, __func__, hva->sts_reg & 0xFF, hva->sfl_reg & 0xF);
+
+	/* check client ID */
+	if (client_id >= MAX_CONTEXT) {
+		dev_err(dev, "%s     %s: bad client identifier: %d\n",
+			ctx->name, __func__, client_id);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		goto out;
+	}
+
+	ctx = hva->contexts_list[client_id];
+
+	switch (status) {
+	case NO_ERROR:
+		dev_dbg(dev, "%s     %s: no error\n",
+			ctx->name, __func__);
+		ctx->hw_err = false;
+		break;
+	case H264_SLICE_READY:
+		dev_dbg(dev, "%s     %s: h264 slice ready\n",
+			ctx->name, __func__);
+		ctx->hw_err = false;
+		break;
+	case H264_FRAME_SKIPPED:
+		dev_dbg(dev, "%s     %s: h264 frame skipped\n",
+			ctx->name, __func__);
+		ctx->hw_err = false;
+		break;
+	case H264_BITSTREAM_OVERSIZE:
+		dev_err(dev, "%s     %s:h264 bitstream oversize\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	case H264_SLICE_LIMIT_SIZE:
+		dev_err(dev, "%s     %s: h264 slice limit size is reached\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	case H264_MAX_SLICE_NUMBER:
+		dev_err(dev, "%s     %s: h264 max slice number is reached\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	case TASK_LIST_FULL:
+		dev_err(dev, "%s     %s:task list full\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	case UNKNOWN_COMMAND:
+		dev_err(dev, "%s     %s:command not known\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	case WRONG_CODEC_OR_RESOLUTION:
+		dev_err(dev, "%s     %s:wrong codec or resolution\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	default:
+		dev_err(dev, "%s     %s:status not recognized\n",
+			ctx->name, __func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+		break;
+	}
+out:
+	complete(&hva->interrupt);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t hva_hw_err_interrupt(int irq, void *data)
+{
+	struct hva_device *hva = data;
+
+	/* read status registers */
+	hva->sts_reg = readl_relaxed(hva->regs + HVA_HIF_FIFO_STS);
+	hva->sfl_reg = readl_relaxed(hva->regs + HVA_HIF_REG_SFL);
+
+	/* read error registers */
+	hva->lmi_err_reg = readl_relaxed(hva->regs + HVA_HIF_REG_LMI_ERR);
+	hva->emi_err_reg = readl_relaxed(hva->regs + HVA_HIF_REG_EMI_ERR);
+	hva->hec_mif_err_reg = readl_relaxed(hva->regs +
+					     HVA_HIF_REG_HEC_MIF_ERR);
+
+	/* acknowledge interruption */
+	writel_relaxed(0x1, hva->regs + HVA_HIF_REG_IT_ACK);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t hva_hw_err_irq_thread(int irq, void *arg)
+{
+	struct hva_device *hva = arg;
+	struct device *dev = hva_to_dev(hva);
+	u8 client_id = 0;
+	struct hva_ctx *ctx;
+
+	dev_dbg(dev, "%s     status :0x%02x fifo level :0x%02x\n",
+		HVA_PREFIX, hva->sts_reg & 0xFF, hva->sfl_reg & 0xF);
+
+	/* check client ID */
+	client_id = (hva->sts_reg & 0xFF00) >> 8;
+	if (client_id >= MAX_CONTEXT) {
+		dev_err(dev, "%s     bad client identifier: %d\n", HVA_PREFIX,
+			client_id);
+		goto out;
+	}
+
+	ctx = hva->contexts_list[client_id];
+
+	if (hva->lmi_err_reg) {
+		dev_err(dev, "%s     local memory interface error :0x%08x\n",
+			ctx->name, hva->lmi_err_reg);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+	}
+
+	if (hva->lmi_err_reg) {
+		dev_err(dev, "%s     external memory iterface error :0x%08x\n",
+			ctx->name, hva->emi_err_reg);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+	}
+
+	if (hva->hec_mif_err_reg) {
+		dev_err(dev, "%s     hec memory interface error :0x%08x\n",
+			ctx->name, hva->hec_mif_err_reg);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+	}
+out:
+	complete(&hva->interrupt);
+
+	return IRQ_HANDLED;
+}
+
+static unsigned long int hva_hw_get_chipset_id(struct hva_device *hva)
+{
+	struct device *dev = hva_to_dev(hva);
+	unsigned long int id;
+
+	mutex_lock(&hva->protect_mutex);
+
+	if (pm_runtime_get_sync(dev) < 0) {
+		dev_err(dev, "%s     get pm_runtime failed\n", HVA_PREFIX);
+		mutex_unlock(&hva->protect_mutex);
+		return -EFAULT;
+	}
+
+	id = readl_relaxed(hva->regs + HVA_HIF_REG_VERSION) &
+			   VERSION_ID_MASK;
+
+	pm_runtime_put_autosuspend(dev);
+
+	mutex_unlock(&hva->protect_mutex);
+
+	switch (id) {
+	case HVA_VERSION_V400:
+		dev_info(dev, "%s     chipset identifier 0x%lx\n",
+			 HVA_PREFIX, id);
+		break;
+	default:
+		dev_err(dev, "%s     unknown chipset identifier 0x%lx\n",
+			HVA_PREFIX, id);
+		id = HVA_VERSION_UNKNOWN;
+		break;
+	}
+
+	return id;
+}
+
+int hva_hw_probe(struct platform_device *pdev, struct hva_device *hva)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *regs;
+	struct resource *esram;
+	int irq = 0;
+	int ret = 0;
+
+	WARN_ON(!hva);
+	hva->pdev = pdev;
+	hva->dev = dev;
+
+	/* get a memory region for mmio */
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	hva->regs = devm_ioremap_resource(dev, regs);
+	if (IS_ERR_OR_NULL(hva->regs)) {
+		dev_err(dev, "%s     failed to get regs\n", HVA_PREFIX);
+		return PTR_ERR(hva->regs);
+	}
+
+	/* get a memory region for esram from device tree */
+	esram = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (IS_ERR_OR_NULL(esram)) {
+		dev_err(dev, "%s     failed to get esram region\n", HVA_PREFIX);
+		return PTR_ERR(esram);
+	}
+
+	hva->esram_addr = esram->start;
+	hva->esram_size = esram->end - esram->start + 1;
+
+	/* get clock resource */
+	hva->clk = devm_clk_get(dev, "clk_hva");
+	if (IS_ERR(hva->clk)) {
+		dev_err(dev, "%s     failed to get clock\n", HVA_PREFIX);
+		return PTR_ERR(hva->clk);
+	}
+
+	ret = clk_prepare(hva->clk);
+	if (ret < 0) {
+		dev_err(dev, "%s     failed to prepare clock\n", HVA_PREFIX);
+		hva->clk = ERR_PTR(-EINVAL);
+		return ret;
+	}
+
+	/* retrieve irq number from board resources */
+	hva->irq_its = platform_get_irq(pdev, 0);
+	if (!hva->irq_its) {
+		dev_err(dev, "%s     failed to get IRQ resource\n", HVA_PREFIX);
+		goto err_clk;
+	}
+
+	/* request irq */
+	ret = devm_request_threaded_irq(dev, hva->irq_its, hva_hw_its_interrupt,
+					hva_hw_its_irq_thread,
+					IRQF_ONESHOT,
+					"hva_its_irq", (void *)hva);
+	if (ret) {
+		dev_err(dev, "%s     failed to register its IRQ 0x%x\n",
+			HVA_PREFIX, irq);
+		goto err_clk;
+	}
+	disable_irq(hva->irq_its);
+
+	/* retrieve irq number from board resources */
+	hva->irq_err = platform_get_irq(pdev, 1);
+	if (!hva->irq_err) {
+		dev_err(dev, "%s     failed to get IRQ resource\n", HVA_PREFIX);
+		goto err_clk;
+	}
+
+	/* request irq */
+	ret = devm_request_threaded_irq(dev, hva->irq_err, hva_hw_err_interrupt,
+					hva_hw_err_irq_thread,
+					IRQF_ONESHOT,
+					"hva_err_irq", (void *)hva);
+	if (ret) {
+		dev_err(dev, "%s     failed to register err IRQ 0x%x\n",
+			HVA_PREFIX, irq);
+		goto err_clk;
+	}
+	disable_irq(hva->irq_err);
+
+	/* initialisation of the protection mutex */
+	mutex_init(&hva->protect_mutex);
+
+	/* initialisation of completion signal */
+	init_completion(&hva->interrupt);
+
+	/* init pm_runtime used for power management */
+	pm_runtime_set_autosuspend_delay(dev, AUTOSUSPEND_DELAY_MS);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_enable(dev);
+
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0) {
+		dev_err(dev, "%s     failed to set PM\n", HVA_PREFIX);
+		goto err_pm;
+	}
+
+	/* check hardware ID */
+	hva->chip_id = hva_hw_get_chipset_id(hva);
+
+	if (hva->chip_id == HVA_VERSION_UNKNOWN) {
+		ret = -EINVAL;
+		goto err_pm;
+	}
+
+	dev_info(dev, "%s     found hva device (id=%lx)\n", HVA_PREFIX,
+		 hva->chip_id);
+
+	return 0;
+err_pm:
+	pm_runtime_put(dev);
+err_clk:
+	if (hva->clk)
+		clk_unprepare(hva->clk);
+
+	return ret;
+}
+
+void hva_hw_remove(struct hva_device *hva)
+{
+	struct device *dev = hva_to_dev(hva);
+
+	/* disable interrupt */
+	disable_irq(hva->irq_its);
+	disable_irq(hva->irq_err);
+
+	pm_runtime_put_autosuspend(dev);
+	pm_runtime_disable(dev);
+}
+
+int hva_hw_runtime_suspend(struct device *dev)
+{
+	struct hva_device *hva = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(hva->clk);
+
+	return 0;
+}
+
+int hva_hw_runtime_resume(struct device *dev)
+{
+	struct hva_device *hva = dev_get_drvdata(dev);
+
+	if (clk_prepare_enable(hva->clk)) {
+		dev_err(hva->dev, "%s     failed to prepare hva clk\n",
+			HVA_PREFIX);
+		return -EINVAL;
+	}
+
+	if (clk_set_rate(hva->clk, CLK_RATE)) {
+		dev_err(dev, "%s     failed to set clock frequency\n",
+			HVA_PREFIX);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int hva_hw_execute_task(struct hva_ctx *ctx, enum hva_hw_cmd_type cmd,
+			struct hva_buffer *task)
+{
+	struct hva_device *hva = ctx_to_hdev(ctx);
+	struct device *dev = hva_to_dev(hva);
+	u8 client_id = ctx->client_id;
+	u32 reg = 0;
+
+	mutex_lock(&hva->protect_mutex);
+
+	/* enable irqs */
+	enable_irq(hva->irq_its);
+	enable_irq(hva->irq_err);
+
+	if (pm_runtime_get_sync(dev) < 0) {
+		dev_err(dev, "%s     get pm_runtime failed\n", ctx->name);
+		ctx->sys_errors++;
+		goto out;
+	}
+
+	reg = readl_relaxed(hva->regs + HVA_HIF_REG_CLK_GATING);
+	switch (cmd) {
+	case H264_ENC:
+	case VP8_ENC:
+		reg |= CLK_GATING_HVC;
+		break;
+	default:
+		dev_warn(dev, "%s     unknown command 0x%x\n", ctx->name, cmd);
+		goto out;
+	}
+	writel_relaxed(reg, hva->regs + HVA_HIF_REG_CLK_GATING);
+
+	dev_dbg(dev, "%s     %s: Write configuration registers\n", ctx->name,
+		__func__);
+
+	/* byte swap config */
+	writel_relaxed(BSM_CFG_VAL1,
+		       hva->regs + HVA_HIF_REG_BSM);
+
+	/*
+	 * define Max Opcode Size and Max Message Size
+	 * for LMI and EMI
+	 */
+	writel_relaxed(MIF_CFG_VAL3,
+		       hva->regs + HVA_HIF_REG_MIF_CFG);
+	writel_relaxed(HEC_MIF_CFG_VAL,
+		       hva->regs + HVA_HIF_REG_HEC_MIF_CFG);
+
+	/* command FIFO: task_id[31:16] client_id[15:8] command_type[7:0] */
+	dev_dbg(dev, "%s     %s: Send task ( cmd:%d, task_desc:%pad)\n",
+		ctx->name, __func__, cmd + (client_id << 8), &task->paddr);
+	writel_relaxed(cmd + (client_id << 8), hva->regs + HVA_HIF_FIFO_CMD);
+	writel_relaxed(task->paddr, hva->regs + HVA_HIF_FIFO_CMD);
+
+	if (!wait_for_completion_timeout(&hva->interrupt,
+					 msecs_to_jiffies(2000))) {
+		dev_err(dev, "%s     %s:Time out on completion\n", ctx->name,
+			__func__);
+		ctx->encode_errors++;
+		ctx->hw_err = true;
+	}
+out:
+	disable_irq(hva->irq_its);
+	disable_irq(hva->irq_err);
+
+	switch (cmd) {
+	case H264_ENC:
+	case VP8_ENC:
+		reg &= ~CLK_GATING_HVC;
+		writel_relaxed(reg, hva->regs + HVA_HIF_REG_CLK_GATING);
+
+		break;
+	default:
+		dev_warn(dev, "%s     unknown command 0x%x\n", ctx->name, cmd);
+	}
+
+	pm_runtime_put_autosuspend(dev);
+	mutex_unlock(&hva->protect_mutex);
+
+	if (ctx->hw_err)
+		return -EFAULT;
+
+	return 0;
+}
diff --git a/drivers/media/platform/sti/hva/hva-hw.h b/drivers/media/platform/sti/hva/hva-hw.h
new file mode 100644
index 0000000..a28f2a5
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-hw.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef HVA_HW_H
+#define HVA_HW_H
+
+/* HVA Versions */
+#define HVA_VERSION_UNKNOWN    0x000
+#define HVA_VERSION_V400       0x400
+
+/* HVA command types */
+enum hva_hw_cmd_type {
+	/* RESERVED = 0x00 */
+	/* RESERVED = 0x01 */
+	H264_ENC = 0x02,
+	/* RESERVED = 0x03 */
+	/* RESERVED = 0x04 */
+	/* RESERVED = 0x05 */
+	VP8_ENC = 0x06,
+	/* RESERVED = 0x07 */
+	REMOVE_CLIENT = 0x08,
+	FREEZE_CLIENT = 0x09,
+	START_CLIENT = 0x0A,
+	FREEZE_ALL = 0x0B,
+	START_ALL = 0x0C,
+	REMOVE_ALL = 0x0D
+};
+
+/**
+ * hw encode error values
+ * NO_ERROR: Success, Task OK
+ * H264_BITSTREAM_OVERSIZE: VECH264 Bitstream size > bitstream buffer
+ * H264_FRAME_SKIPPED: VECH264 Frame skipped (refers to CPB Buffer Size)
+ * H264_SLICE_LIMIT_SIZE: VECH264 MB > slice limit size
+ * H264_MAX_SLICE_NUMBER: VECH264 max slice number reached
+ * H264_SLICE_READY: VECH264 Slice ready
+ * TASK_LIST_FULL: HVA/FPC task list full
+		   (discard latest transform command)
+ * UNKNOWN_COMMAND: Transform command not known by HVA/FPC
+ * WRONG_CODEC_OR_RESOLUTION: Wrong Codec or Resolution Selection
+ * NO_INT_COMPLETION: Time-out on interrupt completion
+ * LMI_ERR: Local Memory Interface Error
+ * EMI_ERR: External Memory Interface Error
+ * HECMI_ERR: HEC Memory Interface Error
+ */
+enum hva_hw_error {
+	NO_ERROR = 0x0,
+	H264_BITSTREAM_OVERSIZE = 0x2,
+	H264_FRAME_SKIPPED = 0x4,
+	H264_SLICE_LIMIT_SIZE = 0x5,
+	H264_MAX_SLICE_NUMBER = 0x7,
+	H264_SLICE_READY = 0x8,
+	TASK_LIST_FULL = 0xF0,
+	UNKNOWN_COMMAND = 0xF1,
+	WRONG_CODEC_OR_RESOLUTION = 0xF4,
+	NO_INT_COMPLETION = 0x100,
+	LMI_ERR = 0x101,
+	EMI_ERR = 0x102,
+	HECMI_ERR = 0x103,
+};
+
+int hva_hw_probe(struct platform_device *pdev, struct hva_device *hva);
+void hva_hw_remove(struct hva_device *hva);
+int hva_hw_runtime_suspend(struct device *dev);
+int hva_hw_runtime_resume(struct device *dev);
+int hva_hw_execute_task(struct hva_ctx *ctx, enum hva_hw_cmd_type cmd,
+			struct hva_buffer *task);
+
+#endif /* HVA_HW_H */
diff --git a/drivers/media/platform/sti/hva/hva-mem.c b/drivers/media/platform/sti/hva/hva-mem.c
new file mode 100644
index 0000000..a191fb2
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-mem.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include "hva.h"
+#include "hva-mem.h"
+
+int hva_mem_alloc(struct hva_ctx *ctx, u32 size, const char *name,
+		  struct hva_buffer **buf)
+{
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_buffer *b;
+	dma_addr_t paddr;
+	void *base;
+	DEFINE_DMA_ATTRS(attrs);
+
+	b = devm_kzalloc(dev, sizeof(*b), GFP_KERNEL);
+	if (!b) {
+		ctx->sys_errors++;
+		return -ENOMEM;
+	}
+
+	dma_set_attr(DMA_ATTR_WRITE_COMBINE, &attrs);
+	base = dma_alloc_attrs(dev, size, &paddr, GFP_KERNEL | GFP_DMA, &attrs);
+	if (!base) {
+		dev_err(dev, "%s %s : dma_alloc_attrs failed for %s (size=%d)\n",
+			ctx->name, __func__, name, size);
+		ctx->sys_errors++;
+		devm_kfree(dev, b);
+		return -ENOMEM;
+	}
+
+	b->size = size;
+	b->paddr = paddr;
+	b->vaddr = base;
+	b->attrs = attrs;
+	b->name = name;
+
+	dev_dbg(dev,
+		"%s allocate %d bytes of HW memory @(virt=%p, phy=%pad): %s\n",
+		ctx->name, size, b->vaddr, &b->paddr, b->name);
+
+	/* return  hva buffer to user */
+	*buf = b;
+
+	return 0;
+}
+
+void hva_mem_free(struct hva_ctx *ctx, struct hva_buffer *buf)
+{
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev,
+		"%s free %d bytes of HW memory @(virt=%p, phy=%pad): %s\n",
+		ctx->name, buf->size, buf->vaddr, &buf->paddr, buf->name);
+
+	dma_free_attrs(dev, buf->size, buf->vaddr, buf->paddr, &buf->attrs);
+
+	devm_kfree(dev, buf);
+}
diff --git a/drivers/media/platform/sti/hva/hva-mem.h b/drivers/media/platform/sti/hva/hva-mem.h
new file mode 100644
index 0000000..2a482e1
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-mem.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef HVA_MEM_H
+#define HVA_MEM_H
+
+int hva_mem_alloc(struct hva_ctx *ctx,
+		  __u32 size,
+		  const char *name,
+		  struct hva_buffer **buf);
+
+void hva_mem_free(struct hva_ctx *ctx,
+		  struct hva_buffer *buf);
+
+#endif /* HVA_MEM_H */
diff --git a/drivers/media/platform/sti/hva/hva-v4l2.c b/drivers/media/platform/sti/hva/hva-v4l2.c
new file mode 100644
index 0000000..b545e7d
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva-v4l2.c
@@ -0,0 +1,1610 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ioctl.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "hva.h"
+#include "hva-hw.h"
+
+#define HVA_NAME "hva"
+
+/*
+ * 1 frame at least for user
+ * limit number of frames to 16
+ */
+#define MAX_FRAMES	16
+#define MIN_FRAMES	1
+
+#define MIN_STREAMS	1
+
+#define HVA_MIN_WIDTH	32
+#define HVA_MAX_WIDTH	1920
+#define HVA_MIN_HEIGHT	32
+#define HVA_MAX_HEIGHT	1920
+
+#define DFT_CFG_WIDTH		HVA_MIN_WIDTH
+#define	DFT_CFG_HEIGHT		HVA_MIN_HEIGHT
+#define DFT_CFG_FRAME_NUM	1
+#define DFT_CFG_FRAME_DEN	30
+
+static const struct hva_frameinfo frame_dflt_fmt = {
+	.fmt		= {
+				.pixelformat	= V4L2_PIX_FMT_NV12,
+				.nb_planes	= 2,
+				.bpp		= 12,
+				.bpp_plane0	= 8,
+				.w_align	= 2,
+				.h_align	= 2
+			  },
+	.width		= DFT_CFG_WIDTH,
+	.height		= DFT_CFG_HEIGHT,
+	.crop		= {0, 0, DFT_CFG_WIDTH, DFT_CFG_HEIGHT},
+	.frame_width	= DFT_CFG_WIDTH,
+	.frame_height	= DFT_CFG_HEIGHT
+};
+
+static const struct hva_streaminfo stream_dflt_fmt = {
+	.streamformat	= V4L2_PIX_FMT_H264,
+	.width		= DFT_CFG_WIDTH,
+	.height		= DFT_CFG_HEIGHT
+};
+
+/* list of stream formats supported by hva hardware */
+const u32 stream_fmt[] = {
+	V4L2_PIX_FMT_H264,
+};
+
+/* list of pixel formats supported by hva hardware */
+static const struct hva_frame_fmt frame_fmts[] = {
+	/* NV12. YUV420SP - 1 plane for Y + 1 plane for (CbCr) */
+	{
+		.pixelformat	= V4L2_PIX_FMT_NV12,
+		.nb_planes	= 2,
+		.bpp		= 12,
+		.bpp_plane0	= 8,
+		.w_align	= 2,
+		.h_align	= 2
+	},
+	/* NV21. YUV420SP - 1 plane for Y + 1 plane for (CrCb) */
+	{
+		.pixelformat	= V4L2_PIX_FMT_NV21,
+		.nb_planes	= 2,
+		.bpp		= 12,
+		.bpp_plane0	= 8,
+		.w_align	= 2,
+		.h_align	= 2
+	},
+};
+
+/* offset to differentiate OUTPUT/CAPTURE @mmap */
+#define MMAP_FRAME_OFFSET BIT(30)
+
+/* registry of available encoders */
+const struct hva_encoder *hva_encoders[] = {
+	&nv12h264enc,
+	&nv21h264enc,
+};
+
+static const struct hva_encoder *hva_find_stream_fmt(struct hva_ctx *ctx,
+						     u32 pixelformat)
+{
+	struct hva_device *hva = ctx_to_hdev(ctx);
+	const struct hva_encoder *enc;
+	unsigned int i;
+
+	for (i = 0; i < hva->nb_of_encoders; i++) {
+		enc = hva->encoders[i];
+		if (enc->streamformat == pixelformat)
+			return enc;
+	}
+
+	return NULL;
+}
+
+static const struct hva_frame_fmt *hva_find_frame_fmt(u32 pixelformat)
+{
+	const struct hva_frame_fmt *fmt;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(frame_fmts); i++) {
+		fmt = &frame_fmts[i];
+		if (fmt->pixelformat == pixelformat)
+			return fmt;
+	}
+
+	return NULL;
+}
+
+static void register_encoder(struct hva_device *hva,
+			     const struct hva_encoder *enc)
+{
+	if (hva->nb_of_encoders >= HVA_MAX_ENCODERS) {
+		dev_warn(hva->dev,
+			 "%s can't register encoder: max nb (%d) is reached!)\n",
+			 enc->name, HVA_MAX_ENCODERS);
+		return;
+	}
+
+	/* those encoder ops are mandatory */
+	WARN_ON(!enc->open);
+	WARN_ON(!enc->close);
+	WARN_ON(!enc->encode);
+
+	hva->encoders[hva->nb_of_encoders] = enc;
+	hva->nb_of_encoders++;
+	dev_info(hva->dev, "%s encoder registered\n", enc->name);
+}
+
+static void register_all(struct hva_device *hva)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(hva_encoders); i++)
+		register_encoder(hva, hva_encoders[i]);
+}
+
+static int hva_open_encoder(struct hva_ctx *ctx, u32 streamformat,
+			    u32 pixelformat, struct hva_encoder **penc)
+{
+	struct hva_device *hva = ctx_to_hdev(ctx);
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_encoder *enc;
+	unsigned int i;
+	int ret;
+
+	/* find an encoder which can deal with these formats */
+	for (i = 0; i < hva->nb_of_encoders; i++) {
+		enc = (struct hva_encoder *)hva->encoders[i];
+		if ((enc->streamformat == streamformat) &&
+		    (enc->pixelformat == pixelformat))
+			break;	/* found */
+	}
+
+	if (i == hva->nb_of_encoders) {
+		dev_err(dev, "%s no encoder found matching %4.4s => %4.4s\n",
+			ctx->name, (char *)&pixelformat, (char *)&streamformat);
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "%s one encoder matching %4.4s => %4.4s\n",
+		ctx->name, (char *)&pixelformat, (char *)&streamformat);
+
+	/* update name instance */
+	snprintf(ctx->name, sizeof(ctx->name), "[%3d:%4.4s]",
+		 hva->instance_id, (char *)&streamformat);
+
+	/* open encoder instance */
+	ret = enc->open(ctx);
+	if (ret) {
+		dev_err(hva->dev, "%s enc->open failed (%d)\n",
+			ctx->name, ret);
+		return ret;
+	}
+
+	*penc = enc;
+
+	return ret;
+}
+
+/* v4l2 ioctl operations */
+
+static int hva_querycap(struct file *file, void *priv,
+			struct v4l2_capability *cap)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct hva_device *hva = ctx_to_hdev(ctx);
+
+	strlcpy(cap->driver, hva->pdev->name, sizeof(cap->driver));
+	strlcpy(cap->card, hva->pdev->name, sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
+		 HVA_NAME);
+
+	cap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+
+	return 0;
+}
+
+static int hva_enum_fmt_stream(struct file *file, void *priv,
+			       struct v4l2_fmtdesc *f)
+{
+	/* index don't have to exceed number of stream format supported */
+	if (f->index >= ARRAY_SIZE(stream_fmt))
+		return -EINVAL;
+
+	/* pixel format */
+	f->pixelformat = stream_fmt[f->index];
+
+	/* compressed */
+	f->flags = V4L2_FMT_FLAG_COMPRESSED;
+
+	return 0;
+}
+
+static int hva_enum_fmt_frame(struct file *file, void *priv,
+			      struct v4l2_fmtdesc *f)
+{
+	/* index don't have to exceed number of  format supported */
+	if (f->index >= ARRAY_SIZE(frame_fmts))
+		return -EINVAL;
+
+	/* pixel format */
+	f->pixelformat = frame_fmts[f->index].pixelformat;
+
+	return 0;
+}
+
+static int hva_g_fmt_stream(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	f->fmt.pix.width = ctx->streaminfo.width;
+	f->fmt.pix.height = ctx->streaminfo.height;
+	f->fmt.pix.field = V4L2_FIELD_NONE;
+	f->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;
+	f->fmt.pix.pixelformat = ctx->streaminfo.streamformat;
+	f->fmt.pix.bytesperline = 0;
+	f->fmt.pix.sizeimage = f->fmt.pix.width * f->fmt.pix.height;
+
+	dev_dbg(dev, "%s G_FMT (stream): %dx%d fmt:%.4s size:%d\n",
+		ctx->name, f->fmt.pix.width, f->fmt.pix.height,
+		(u8 *)&f->fmt.pix.pixelformat, f->fmt.pix.sizeimage);
+	return 0;
+}
+
+static int hva_g_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_frame_fmt *fmt = &ctx->frameinfo.fmt;
+	int width = ctx->frameinfo.frame_width;
+	int height = ctx->frameinfo.frame_height;
+
+	f->fmt.pix.width = ctx->frameinfo.width;
+	f->fmt.pix.height = ctx->frameinfo.height;
+	f->fmt.pix.field = V4L2_FIELD_NONE;
+	f->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;
+	f->fmt.pix.pixelformat = fmt->pixelformat;
+	f->fmt.pix.bytesperline = (width * fmt->bpp_plane0) / 8;
+	f->fmt.pix.sizeimage = (width * height * fmt->bpp) / 8;
+
+	dev_dbg(dev, "%s G_FMT (frame): %dx%d fmt:%.4s size:%d\n",
+		ctx->name, f->fmt.pix.width, f->fmt.pix.height,
+		(u8 *)&f->fmt.pix.pixelformat, f->fmt.pix.sizeimage);
+
+	return 0;
+}
+
+static int hva_try_fmt_stream(struct file *file, void *priv,
+			      struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	const struct hva_encoder *enc;
+	u32 width, height;
+
+	enc = hva_find_stream_fmt(ctx, pix->pixelformat);
+	if (!enc) {
+		dev_dbg(dev, "%s TRY_FMT (stream): unsupported format %.4s\n",
+			ctx->name, (char *)&pix->pixelformat);
+		return -EINVAL;
+	}
+
+	/*
+	 * if the frame resolution is already fixed, only allow the same stream
+	 * resolution
+	 */
+	width = pix->width;
+	height = pix->height;
+	if (ctx->flags & HVA_FLAG_FRAMEINFO) {
+		pix->width = ctx->frameinfo.width;
+		pix->height = ctx->frameinfo.height;
+		if ((pix->width != width) || (pix->height != height))
+			dev_dbg(dev,
+				"%s TRY_FMT (stream): same resolution as frame %dx%d -> %dx%d\n",
+				ctx->name, width, height,
+				pix->width, pix->height);
+	} else {
+		/* adjust width & height */
+		v4l_bound_align_image(&pix->width,
+				      HVA_MIN_WIDTH, enc->max_width,
+				      0,
+				      &pix->height,
+				      HVA_MIN_HEIGHT, enc->max_height,
+				      0,
+				      0);
+
+		if ((pix->width != width) || (pix->height != height))
+			dev_dbg(dev,
+				"%s TRY_FMT (stream): resolution updated %dx%d -> %dx%d\n",
+				ctx->name, width, height,
+				pix->width, pix->height);
+	}
+
+	pix->bytesperline = 0;
+	pix->sizeimage = pix->width * pix->height;
+	pix->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	pix->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int hva_try_fmt_frame(struct file *file, void *priv,
+			     struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	const struct hva_frame_fmt *format;
+	u32 width, height;
+
+	format = hva_find_frame_fmt(pix->pixelformat);
+	if (!format) {
+		dev_dbg(dev, "%s TRY_FMT (frame): unsupported format %.4s\n",
+			ctx->name, (char *)&pix->pixelformat);
+		return -EINVAL;
+	}
+
+	/* adjust width & height */
+	width = pix->width;
+	height = pix->height;
+	v4l_bound_align_image(&pix->width,
+			      HVA_MIN_WIDTH, HVA_MAX_WIDTH,
+			      ffs(format->w_align) - 1,
+			      &pix->height,
+			      HVA_MIN_HEIGHT, HVA_MAX_HEIGHT,
+			      ffs(format->h_align) - 1,
+			      0);
+
+	if ((pix->width != width) || (pix->height != height))
+		dev_dbg(dev,
+			"%s TRY_FMT (frame): resolution updated %dx%d -> %dx%d\n",
+			ctx->name, width, height, pix->width, pix->height);
+
+	width = ALIGN(pix->width, 16);
+	height = ALIGN(pix->height, 16);
+	pix->bytesperline = (width * format->bpp_plane0) / 8;
+	pix->sizeimage = (width * height * format->bpp) / 8;
+	pix->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	pix->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int hva_s_fmt_stream(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	int ret;
+
+	dev_dbg(dev, "%s S_FMT (stream): %dx%d fmt:%.4s size:%d\n",
+		ctx->name, f->fmt.pix.width, f->fmt.pix.height,
+		(u8 *)&f->fmt.pix.pixelformat, f->fmt.pix.sizeimage);
+
+	ret = hva_try_fmt_stream(file, fh, f);
+	if (ret) {
+		dev_err(dev,
+			"%s S_FMT (stream): unsupported format %.4s\n",
+			ctx->name, (char *)&f->fmt.pix.pixelformat);
+		return ret;
+	}
+
+	if (vb2_is_streaming(&ctx->q_stream)) {
+		dev_err(dev, "%s S_FMT (stream): queue busy\n", ctx->name);
+		return -EBUSY;
+	}
+
+	ctx->streaminfo.width = f->fmt.pix.width;
+	ctx->streaminfo.height = f->fmt.pix.height;
+	ctx->streaminfo.streamformat = f->fmt.pix.pixelformat;
+	ctx->streaminfo.dpb = 1;
+	ctx->flags |= HVA_FLAG_STREAMINFO;
+
+	return 0;
+}
+
+static int hva_s_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	const struct hva_frame_fmt *fmt;
+	int ret;
+
+	dev_dbg(dev, "%s S_FMT (frame): %dx%d fmt %.4s size %d\n",
+		ctx->name, f->fmt.pix.width, f->fmt.pix.height,
+		(u8 *)&f->fmt.pix.pixelformat, f->fmt.pix.sizeimage);
+
+	ret = hva_try_fmt_frame(file, fh, f);
+	if (ret) {
+		dev_err(dev, "%s S_FMT (frame): unsupported format %.4s\n",
+			ctx->name, (char *)&f->fmt.pix.pixelformat);
+		return ret;
+	}
+
+	if (vb2_is_streaming(&ctx->q_frame)) {
+		dev_err(dev, "%s S_FMT (frame): queue busy\n", ctx->name);
+		return -EBUSY;
+	}
+
+	fmt = hva_find_frame_fmt(pix->pixelformat);
+	if (!fmt)
+		return -EINVAL;
+
+	memcpy(&ctx->frameinfo.fmt, fmt, sizeof(struct hva_frame_fmt));
+	ctx->frameinfo.frame_width = ALIGN(pix->width, 16);
+	ctx->frameinfo.frame_height = ALIGN(pix->height, 16);
+	ctx->frameinfo.width = pix->width;
+	ctx->frameinfo.height = pix->height;
+	ctx->frameinfo.crop.width = pix->width;
+	ctx->frameinfo.crop.height = pix->height;
+	ctx->frameinfo.crop.left = 0;
+	ctx->frameinfo.crop.top = 0;
+	ctx->flags |= HVA_FLAG_FRAMEINFO;
+
+	return 0;
+}
+
+static int hva_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct hva_ctx *ctx = container_of(ctrl->handler, struct hva_ctx,
+					   ctrl_handler);
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev, "%s S_CTRL: id = %d, val = %d\n", ctx->name,
+		ctrl->id, ctrl->val);
+
+	switch (ctrl->id) {
+	case V4L2_CID_MPEG_VIDEO_BITRATE_MODE:
+		ctx->ctrls.bitrate_mode = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_GOP_SIZE:
+		ctx->ctrls.gop_size = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_BITRATE:
+		ctx->ctrls.bitrate = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_ASPECT:
+		ctx->ctrls.aspect = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_PROFILE:
+		ctx->ctrls.profile = ctrl->val;
+		if (ctx->flags & HVA_FLAG_STREAMINFO)
+			snprintf(ctx->streaminfo.profile,
+				 sizeof(ctx->streaminfo.profile),
+				 "%s", profile_str(ctx->ctrls.profile));
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_LEVEL:
+		ctx->ctrls.level = ctrl->val;
+		if (ctx->flags & HVA_FLAG_STREAMINFO)
+			snprintf(ctx->streaminfo.level,
+				 sizeof(ctx->streaminfo.level),
+				 "%s", level_str(ctx->ctrls.level));
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:
+		ctx->ctrls.entropy_mode = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE:
+		ctx->ctrls.cpb_size = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM:
+		ctx->ctrls.dct8x8 = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_MIN_QP:
+		ctx->ctrls.qpmin = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_MAX_QP:
+		ctx->ctrls.qpmax = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE:
+		ctx->ctrls.vui_sar = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC:
+		ctx->ctrls.vui_sar_idc = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING:
+		ctx->ctrls.sei_fp = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE:
+		ctx->ctrls.sei_fp_type = ctrl->val;
+		break;
+	default:
+		dev_dbg(dev, "%s S_CTRL: invalid control (id = %d)\n",
+			ctx->name, ctrl->id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops hva_ctrl_ops = {
+	.s_ctrl = hva_s_ctrl,
+};
+
+static int hva_ctrls_setup(struct hva_ctx *ctx)
+{
+	struct device *dev = ctx_to_dev(ctx);
+	u64 mask;
+	enum v4l2_mpeg_video_h264_sei_fp_arrangement_type sei_fp_type =
+		V4L2_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE_TOP_BOTTOM;
+
+	v4l2_ctrl_handler_init(&ctx->ctrl_handler, 15);
+
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_BITRATE_MODE,
+			       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR,
+			       0,
+			       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_GOP_SIZE,
+			  1, 60, 1, 16);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_BITRATE,
+			  1, 50000, 1, 20000);
+
+	mask = ~(1 << V4L2_MPEG_VIDEO_ASPECT_1x1);
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_ASPECT,
+			       V4L2_MPEG_VIDEO_ASPECT_1x1,
+			       mask,
+			       V4L2_MPEG_VIDEO_ASPECT_1x1);
+
+	mask = ~((1 << V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE) |
+		 (1 << V4L2_MPEG_VIDEO_H264_PROFILE_MAIN) |
+		 (1 << V4L2_MPEG_VIDEO_H264_PROFILE_HIGH) |
+		 (1 << V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH));
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_PROFILE,
+			       V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH,
+			       mask,
+			       V4L2_MPEG_VIDEO_H264_PROFILE_HIGH);
+
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_LEVEL,
+			       V4L2_MPEG_VIDEO_H264_LEVEL_4_2,
+			       0,
+			       V4L2_MPEG_VIDEO_H264_LEVEL_4_0);
+
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE,
+			       V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC,
+			       0,
+			       V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_CPB_SIZE,
+			  1, 62500, 1, 25000);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM,
+			  0, 1, 1, 0);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_MIN_QP,
+			  0, 51, 1, 5);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_MAX_QP,
+			  0, 51, 1, 51);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_ENABLE,
+			  0, 1, 1, 1);
+
+	mask = ~(1 << V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1);
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_VUI_SAR_IDC,
+			       V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1,
+			       mask,
+			       V4L2_MPEG_VIDEO_H264_VUI_SAR_IDC_1x1);
+
+	v4l2_ctrl_new_std(&ctx->ctrl_handler, &hva_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_SEI_FRAME_PACKING,
+			  0, 1, 1, 0);
+
+	mask = ~(1 << sei_fp_type);
+	v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &hva_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_SEI_FP_ARRANGEMENT_TYPE,
+			       sei_fp_type,
+			       mask,
+			       sei_fp_type);
+
+	if (ctx->ctrl_handler.error) {
+		int err = ctx->ctrl_handler.error;
+
+		dev_dbg(dev, "%s controls setup failed (%d)\n", ctx->name,
+			err);
+		v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+		return err;
+	}
+
+	v4l2_ctrl_handler_setup(&ctx->ctrl_handler);
+	return 0;
+}
+
+static int hva_s_parm(struct file *file, void *fh, struct v4l2_streamparm *sp)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	ctx->time_per_frame.numerator = sp->parm.capture.timeperframe.numerator;
+	ctx->time_per_frame.denominator =
+	    sp->parm.capture.timeperframe.denominator;
+
+	dev_dbg(dev, "%s set parameters %d/%d\n",
+		ctx->name, ctx->time_per_frame.numerator,
+		ctx->time_per_frame.denominator);
+
+	return 0;
+}
+
+static int hva_g_parm(struct file *file, void *fh, struct v4l2_streamparm *sp)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	sp->parm.capture.timeperframe.numerator = ctx->time_per_frame.numerator;
+	sp->parm.capture.timeperframe.denominator =
+	    ctx->time_per_frame.denominator;
+
+	dev_dbg(dev, "%s get parameters %d/%d\n",
+		ctx->name, ctx->time_per_frame.numerator,
+		ctx->time_per_frame.denominator);
+
+	return 0;
+}
+
+static int hva_reqbufs(struct file *file, void *priv,
+		       struct v4l2_requestbuffers *reqbufs)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev, "%s REQBUFS %s\n", ctx->name, to_type_str(reqbufs->type));
+
+	return vb2_reqbufs(get_queue(ctx, reqbufs->type), reqbufs);
+}
+
+static int hva_create_bufs(struct file *file, void *priv,
+			   struct v4l2_create_buffers *create)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev, "%s CREATE_BUFS %s\n", ctx->name,
+		to_type_str(create->format.type));
+
+	return vb2_create_bufs(get_queue(ctx, create->format.type), create);
+}
+
+static int hva_querybuf(struct file *file, void *priv, struct v4l2_buffer *b)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	int ret = 0;
+
+	dev_dbg(dev, "%s QUERYBUF %s[%d]\n", ctx->name,
+		to_type_str(b->type), b->index);
+
+	ret = vb2_querybuf(get_queue(ctx, b->type), b);
+	if (ret)
+		return ret;
+
+	/* add an offset to differentiate OUTPUT/CAPTURE @mmap time */
+	if ((b->memory == V4L2_MEMORY_MMAP) &&
+	    (b->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)) {
+		b->m.offset += MMAP_FRAME_OFFSET;
+	}
+
+	return 0;
+}
+
+static int hva_expbuf(struct file *file, void *fh, struct v4l2_exportbuffer *b)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev, "%s EXPBUF %s\n", ctx->name, to_type_str(b->type));
+
+	return vb2_expbuf(get_queue(ctx, b->type), b);
+}
+
+static int hva_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct vb2_queue *q = get_queue(ctx, b->type);
+
+	/* copy bytesused field from v4l2 buffer to vb2 buffer */
+	if ((b->index < MAX_FRAMES) &&
+	    (b->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)) {
+		struct hva_stream *s = (struct hva_stream *)q->bufs[b->index];
+
+		s->payload = b->bytesused;
+	}
+
+	return vb2_qbuf(q, b);
+}
+
+static int hva_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct vb2_queue *q = get_queue(ctx, b->type);
+
+	return vb2_dqbuf(q, b, file->f_flags & O_NONBLOCK);
+}
+
+static int hva_streamon(struct file *file, void *priv, enum v4l2_buf_type type)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+
+	return vb2_streamon(get_queue(ctx, type), type);
+}
+
+static int hva_streamoff(struct file *file, void *priv, enum v4l2_buf_type type)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+
+	return vb2_streamoff(get_queue(ctx, type), type);
+}
+
+static int is_rect_enclosed(struct v4l2_rect *a, struct v4l2_rect *b)
+{
+	/* return 1 if a is enclosed in b, or 0 otherwise. */
+	if (a->left < b->left || a->top < b->top)
+		return 0;
+
+	if (a->left + a->width > b->left + b->width)
+		return 0;
+
+	if (a->top + a->height > b->top + b->height)
+		return 0;
+
+	return 1;
+}
+
+static int hva_g_selection(struct file *file, void *fh,
+			   struct v4l2_selection *s)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+
+	if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+		dev_dbg(dev, "%s G_SELECTION: invalid type (%d)\n",
+			ctx->name, s->type);
+		return -EINVAL;
+	}
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_CROP:
+		/* cropped frame */
+		s->r = ctx->frameinfo.crop;
+		break;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		/* complete frame */
+		s->r.left = 0;
+		s->r.top = 0;
+		s->r.width = ctx->frameinfo.width;
+		s->r.height = ctx->frameinfo.height;
+		break;
+	default:
+		dev_dbg(dev, "%s G_SELECTION: invalid target (%d)\n",
+			ctx->name, s->target);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int hva_s_selection(struct file *file, void *fh,
+			   struct v4l2_selection *s)
+{
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	struct v4l2_rect *in, out;
+
+	if ((s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) ||
+	    (s->target != V4L2_SEL_TGT_CROP)) {
+		dev_dbg(dev, "%s S_SELECTION: invalid type (%d)\n",
+			ctx->name, s->type);
+		return -EINVAL;
+	}
+
+	in = &s->r;
+	out = *in;
+
+	/* align and check origin */
+	out.left = ALIGN(in->left, ctx->frameinfo.fmt.w_align);
+	out.top = ALIGN(in->top, ctx->frameinfo.fmt.h_align);
+
+	if (((out.left + out.width) >  ctx->frameinfo.width) ||
+	    ((out.top + out.height) >  ctx->frameinfo.height)) {
+		dev_dbg(dev, "%s S_SELECTION: invalid crop %dx%d@(%d,%d)\n",
+			ctx->name, out.width, out.height,
+			out.left, out.top);
+		return -EINVAL;
+	}
+
+	/* checks adjust constraints flags */
+	if (s->flags & V4L2_SEL_FLAG_LE && !is_rect_enclosed(&out, in))
+		return -ERANGE;
+
+	if (s->flags & V4L2_SEL_FLAG_GE && !is_rect_enclosed(in, &out))
+		return -ERANGE;
+
+	if ((out.left != in->left) || (out.top != in->top) ||
+	    (out.width != in->width) || (out.height != in->height))
+		*in = out;
+
+	ctx->frameinfo.crop = s->r;
+
+	return 0;
+}
+
+/* vb2 ioctls operations */
+
+static int hva_vb2_frame_queue_setup(struct vb2_queue *q,
+				     unsigned int *num_buffers,
+				     unsigned int *num_planes,
+				     unsigned int sizes[], void *alloc_ctxs[])
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	int width = ctx->frameinfo.frame_width;
+	int height = ctx->frameinfo.frame_height;
+	unsigned int size;
+
+	dev_dbg(dev, "%s frame queue setup: num_buffers %d\n", ctx->name,
+		*num_buffers);
+
+	/* setup nb of frame buffers needed =
+	 * user need (*num_buffer given, usually for grab pipeline) +
+	 * encoder internal need
+	 */
+	if (*num_buffers > MAX_FRAMES) {
+		dev_dbg(dev,
+			"%s frame queue setup: num_buffers too high (%d), cut to %d\n",
+			ctx->name, *num_buffers, MAX_FRAMES);
+		*num_buffers = MAX_FRAMES;
+	}
+
+	if (sizes[0])
+		dev_dbg(dev,
+			"%s frame queue setup: sizes[0] already set to %d\n",
+			ctx->name, sizes[0]);
+
+	if (!(ctx->flags & HVA_FLAG_FRAMEINFO)) {
+		dev_dbg(dev,
+			"%s frame queue setup: frame format not set, using default\n",
+			ctx->name);
+	}
+
+	alloc_ctxs[0] = ctx->hva_dev->alloc_ctx;
+	size = (width * height * ctx->frameinfo.fmt.bpp) / 8;
+
+	if (*num_planes)
+		return sizes[0] < size ? -EINVAL : 0;
+
+	/* only one plane supported */
+	*num_planes = 1;
+	sizes[0] = size;
+
+	return 0;
+}
+
+static int hva_vb2_frame_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_frame *fm = (struct hva_frame *)vb;
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+
+	if (vbuf->field == V4L2_FIELD_ANY)
+		vbuf->field = V4L2_FIELD_NONE;
+	if (vbuf->field != V4L2_FIELD_NONE) {
+		dev_dbg(dev, "%s frame[%d] prepare: %d field not supported\n",
+			ctx->name, vb->index, vbuf->field);
+		return -EINVAL;
+	}
+
+	if (!fm->prepared) {
+		/* get memory addresses */
+		fm->vaddr = vb2_plane_vaddr(&fm->v4l2.vb2_buf, 0);
+		fm->paddr =
+			vb2_dma_contig_plane_dma_addr(&fm->v4l2.vb2_buf, 0);
+		fm->prepared = true;
+
+		ctx->num_frames++;
+
+		dev_dbg(dev, "%s frame[%d] prepared; virt=%p, phy=%pad\n",
+			ctx->name, vb->index, fm->vaddr,
+			&fm->paddr);
+	}
+
+	return 0;
+}
+
+static void hva_vb2_frame_queue(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	const struct hva_encoder *enc = ctx_to_enc(ctx);
+	struct hva_frame *fm = NULL;
+	struct hva_stream *sr = NULL;
+	int ret = 0;
+
+	fm = (struct hva_frame *)vb;
+	fm->v4l2.sequence = ctx->frame_num++;
+
+	if (!vb2_is_streaming(q)) {
+		vb2_buffer_done(&fm->v4l2.vb2_buf, VB2_BUF_STATE_ERROR);
+		return;
+	}
+
+	/* get a free stream buffer */
+	if (list_empty(&ctx->list_stream)) {
+		dev_err(dev, "%s no free buffer for stream!\n",	ctx->name);
+		ctx->sys_errors++;
+		goto err;
+	}
+	sr = list_first_entry(&ctx->list_stream, struct hva_stream, list);
+
+	if (!sr)
+		goto err;
+
+	list_del(&sr->list);
+
+	/* encode the frame & get stream unit */
+	ret = enc->encode(ctx, fm, sr);
+	if (ret)
+		goto err;
+
+	/* propagate frame timestamp */
+	sr->v4l2.vb2_buf.timestamp = fm->v4l2.vb2_buf.timestamp;
+	sr->v4l2.field = V4L2_FIELD_NONE;
+	sr->v4l2.sequence = ctx->stream_num - 1;
+
+	ctx->num_streams++;
+
+	vb2_buffer_done(&sr->v4l2.vb2_buf, VB2_BUF_STATE_DONE);
+	vb2_buffer_done(&fm->v4l2.vb2_buf, VB2_BUF_STATE_DONE);
+
+	return;
+err:
+	if (sr)
+		vb2_buffer_done(&sr->v4l2.vb2_buf, VB2_BUF_STATE_ERROR);
+
+	vb2_buffer_done(&fm->v4l2.vb2_buf, VB2_BUF_STATE_ERROR);
+}
+
+static int hva_vb2_frame_start_streaming(struct vb2_queue *q,
+					 unsigned int count)
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	int ret = 0;
+
+	dev_dbg(dev, "%s frame start streaming\n", ctx->name);
+
+	/* open encoder when both start_streaming have been called */
+	if (!vb2_start_streaming_called(&ctx->q_stream))
+		return 0;
+
+	if (!ctx->encoder)
+		ret = hva_open_encoder(ctx,
+				       ctx->streaminfo.streamformat,
+				       ctx->frameinfo.fmt.pixelformat,
+				       &ctx->encoder);
+
+	return ret;
+}
+
+static void hva_vb2_frame_stop_streaming(struct vb2_queue *q)
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+
+	dev_dbg(dev, "%s frame stop streaming\n", ctx->name);
+
+	ctx->frame_num = 0;
+}
+
+static int hva_vb2_stream_queue_setup(struct vb2_queue *q,
+				      unsigned int *num_buffers,
+				      unsigned int *num_planes,
+				      unsigned int sizes[], void *alloc_ctxs[])
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	int width = ctx->streaminfo.width;
+	int height = ctx->streaminfo.height;
+	unsigned int size;
+
+	dev_dbg(dev, "%s stream queue setup: num_buffers %d\n", ctx->name,
+		*num_buffers);
+
+	if (sizes[0])
+		dev_warn(dev,
+			 "%s stream queue setup: sizes[0] already set to %d\n",
+			 ctx->name, sizes[0]);
+
+	if (!(ctx->flags & HVA_FLAG_STREAMINFO)) {
+		dev_err(dev,
+			"%s stream queue setup: stream format not set, using default\n",
+			ctx->name);
+	}
+
+	alloc_ctxs[0] = ctx->hva_dev->alloc_ctx;
+	size = width * height;
+
+	if (*num_planes)
+		return sizes[0] < size ? -EINVAL : 0;
+
+	/* only one plane supported */
+	*num_planes = 1;
+	sizes[0] = size;
+
+	return 0;
+}
+
+static int hva_vb2_stream_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_stream *sr = (struct hva_stream *)vb;
+
+	if (!sr->prepared) {
+		/* get memory addresses */
+		sr->vaddr = vb2_plane_vaddr(&sr->v4l2.vb2_buf, 0);
+		sr->paddr = vb2_dma_contig_plane_dma_addr(&sr->v4l2.vb2_buf, 0);
+		sr->prepared = true;
+
+		dev_dbg(dev, "%s stream[%d] prepared; virt=%p, phy=%pad\n",
+			ctx->name, vb->index, sr->vaddr, &sr->paddr);
+	}
+
+	return 0;
+}
+
+static void hva_vb2_stream_queue(struct vb2_buffer *vb)
+{
+	struct vb2_queue *q = vb->vb2_queue;
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct hva_stream *sr = (struct hva_stream *)vb;
+
+	/* check validity of video stream */
+	if (vb) {
+		/* enqueue to the stream list */
+		list_add(&sr->list, &ctx->list_stream);
+	}
+}
+
+static int hva_vb2_stream_start_streaming(struct vb2_queue *q,
+					  unsigned int count)
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	int ret = 0;
+
+	dev_dbg(dev, "%s stream start streaming\n", ctx->name);
+
+	/* open encoder when both start_streaming have been called */
+	if (!vb2_start_streaming_called(&ctx->q_frame))
+		return 0;
+
+	if (!ctx->encoder)
+		ret = hva_open_encoder(ctx,
+				       ctx->streaminfo.streamformat,
+				       ctx->frameinfo.fmt.pixelformat,
+				       &ctx->encoder);
+
+	return ret;
+}
+
+static void hva_vb2_stream_stop_streaming(struct vb2_queue *q)
+{
+	struct hva_ctx *ctx = fh_to_ctx(q->drv_priv);
+	struct device *dev = ctx_to_dev(ctx);
+	struct hva_stream *sr, *node;
+
+	dev_dbg(dev, "%s stream stop streaming\n", ctx->name);
+
+	ctx->stream_num = 0;
+
+	/* release all active buffers */
+	list_for_each_entry_safe(sr, node, &ctx->list_stream, list) {
+		list_del_init(&sr->list);
+		vb2_buffer_done(&sr->v4l2.vb2_buf, VB2_BUF_STATE_ERROR);
+	}
+}
+
+static struct vb2_ops hva_vb2_frame_ops = {
+	.queue_setup		= hva_vb2_frame_queue_setup,
+	.buf_prepare		= hva_vb2_frame_prepare,
+	.buf_queue		= hva_vb2_frame_queue,
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+	.start_streaming	= hva_vb2_frame_start_streaming,
+	.stop_streaming		= hva_vb2_frame_stop_streaming
+};
+
+static struct vb2_ops hva_vb2_stream_ops = {
+	.queue_setup		= hva_vb2_stream_queue_setup,
+	.buf_prepare		= hva_vb2_stream_prepare,
+	.buf_queue		= hva_vb2_stream_queue,
+	.wait_prepare		= vb2_ops_wait_prepare,
+	.wait_finish		= vb2_ops_wait_finish,
+	.start_streaming	= hva_vb2_stream_start_streaming,
+	.stop_streaming		= hva_vb2_stream_stop_streaming,
+};
+
+/* file basics operations */
+
+static int hva_open(struct file *file)
+{
+	struct hva_device *hva = video_drvdata(file);
+	struct vb2_queue *q;
+	struct device *dev;
+	struct hva_ctx *ctx;
+	int ret = 0;
+	unsigned int i;
+
+	WARN_ON(!hva);
+	dev = hva->dev;
+
+	mutex_lock(&hva->lock);
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		mutex_unlock(&hva->lock);
+		return -ENOMEM;
+	}
+	ctx->hva_dev = hva;
+
+	/* store the context address in the contexts list */
+	for (i = 0; i < MAX_CONTEXT; i++) {
+		if (!hva->contexts_list[i]) {
+			hva->contexts_list[i] = ctx;
+			/* save client id in context */
+			ctx->client_id = i;
+			break;
+		}
+	}
+
+	v4l2_fh_init(&ctx->fh, video_devdata(file));
+	file->private_data = &ctx->fh;
+	v4l2_fh_add(&ctx->fh);
+
+	ret = hva_ctrls_setup(ctx);
+	if (ret) {
+		dev_err(dev, "%s [x:x] failed to setup controls\n",
+			HVA_PREFIX);
+		ctx->sys_errors++;
+		goto err_fh_del;
+	}
+	ctx->fh.ctrl_handler = &ctx->ctrl_handler;
+
+	/* setup vb2 queue for frame */
+	q = &ctx->q_frame;
+	q->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	q->io_modes = VB2_MMAP | VB2_DMABUF;
+	q->min_buffers_needed = MIN_FRAMES;
+
+	/* save file handle to private data field of the queue */
+	q->drv_priv = &ctx->fh;
+
+	/* overload vb2 buffer size with private struct */
+	q->buf_struct_size = sizeof(struct hva_frame);
+
+	q->ops = &hva_vb2_frame_ops;
+	q->mem_ops = (struct vb2_mem_ops *)&vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	q->lock = &hva->lock;
+
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(dev, "%s [x:x] vb2_queue_init(frame) failed (%d)\n",
+			HVA_PREFIX,  ret);
+		ctx->sys_errors++;
+		goto err_ctrls;
+	}
+
+	/* setup vb2 queue for stream */
+	q = &ctx->q_stream;
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_DMABUF;
+	q->min_buffers_needed = MIN_STREAMS;
+
+	/* save file handle to private data field of the queue */
+	q->drv_priv = &ctx->fh;
+
+	/* overload vb2 buffer size with private struct */
+	q->buf_struct_size = sizeof(struct hva_stream);
+
+	q->ops = &hva_vb2_stream_ops;
+	q->mem_ops = (struct vb2_mem_ops *)&vb2_dma_contig_memops;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	q->lock = &hva->lock;
+
+	ret = vb2_queue_init(q);
+	if (ret) {
+		dev_err(dev, "%s [x:x] vb2_queue_init(stream) failed (%d)\n",
+			HVA_PREFIX, ret);
+		ctx->sys_errors++;
+		goto err_queue_del_frame;
+	}
+
+	/* initialize the list of stream buffers */
+	INIT_LIST_HEAD(&ctx->list_stream);
+
+	/* name this instance */
+	hva->instance_id++;	/* rolling id to identify this instance */
+	snprintf(ctx->name, sizeof(ctx->name), "[%3d:----]", hva->instance_id);
+
+	/* set by default time per frame */
+	ctx->time_per_frame.numerator = DFT_CFG_FRAME_NUM;
+	ctx->time_per_frame.denominator = DFT_CFG_FRAME_DEN;
+
+	/* default format */
+	ctx->streaminfo = stream_dflt_fmt;
+	ctx->frameinfo = frame_dflt_fmt;
+
+	hva->nb_of_instances++;
+
+	mutex_unlock(&hva->lock);
+
+	return 0;
+
+err_queue_del_frame:
+	vb2_queue_release(&ctx->q_frame);
+err_ctrls:
+	v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+err_fh_del:
+	v4l2_fh_del(&ctx->fh);
+	v4l2_fh_exit(&ctx->fh);
+	hva->contexts_list[ctx->client_id] = NULL;
+	devm_kfree(dev, ctx);
+
+	mutex_unlock(&hva->lock);
+
+	return ret;
+}
+
+static int hva_release(struct file *file)
+{
+	struct hva_device *hva = video_drvdata(file);
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	const struct hva_encoder *enc = ctx_to_enc(ctx);
+
+	dev_dbg(dev, "%s release instance\n", ctx->name);
+
+	mutex_lock(&hva->lock);
+
+	/* free queues */
+	vb2_queue_release(&ctx->q_frame);
+	vb2_queue_release(&ctx->q_stream);
+
+	v4l2_ctrl_handler_free(&ctx->ctrl_handler);
+
+	v4l2_fh_del(&ctx->fh);
+	v4l2_fh_exit(&ctx->fh);
+
+	/* clear context in contexts list */
+	if ((ctx->client_id >= MAX_CONTEXT) ||
+	    (hva->contexts_list[ctx->client_id] != ctx)) {
+		dev_err(dev, "%s can't clear context in contexts list!\n",
+			ctx->name);
+		ctx->sys_errors++;
+	}
+	hva->contexts_list[ctx->client_id] = NULL;
+
+	/* close encoder */
+	if (enc)
+		enc->close(ctx);
+
+	devm_kfree(dev, ctx);
+
+	hva->nb_of_instances--;
+
+	mutex_unlock(&hva->lock);
+
+	return 0;
+}
+
+static int hva_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct hva_device *hva = video_drvdata(file);
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct device *dev = ctx_to_dev(ctx);
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	enum v4l2_buf_type type;
+	int ret;
+
+	mutex_lock(&hva->lock);
+
+	/* offset used to differentiate OUTPUT/CAPTURE */
+	if (offset < MMAP_FRAME_OFFSET) {
+		type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	} else {
+		type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		vma->vm_pgoff -= (MMAP_FRAME_OFFSET >> PAGE_SHIFT);
+	}
+
+	/* vb2 call */
+	ret = vb2_mmap(get_queue(ctx, type), vma);
+	if (ret) {
+		dev_err(dev, "%s vb2_mmap failed (%d)\n", ctx->name, ret);
+		ctx->sys_errors++;
+		mutex_unlock(&hva->lock);
+		return ret;
+	}
+
+	mutex_unlock(&hva->lock);
+
+	return 0;
+}
+
+static unsigned int hva_poll(struct file *file, poll_table *wait)
+{
+	struct hva_device *hva = video_drvdata(file);
+	struct hva_ctx *ctx = fh_to_ctx(file->private_data);
+	struct video_device *vfd = video_devdata(file);
+	unsigned long req_events = poll_requested_events(wait);
+	struct vb2_queue *src_q, *dst_q;
+	struct vb2_buffer *src_vb = NULL, *dst_vb = NULL;
+	unsigned int rc = 0;
+	unsigned long flags;
+
+	mutex_lock(&hva->lock);
+
+	if (test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags)) {
+		struct v4l2_fh *fh = file->private_data;
+
+		if (v4l2_event_pending(fh))
+			rc = POLLPRI;
+		else if (req_events & POLLPRI)
+			poll_wait(file, &fh->wait, wait);
+		if (!(req_events &
+			(POLLOUT | POLLWRNORM | POLLIN | POLLRDNORM)))
+			goto end;
+	}
+
+	src_q = &ctx->q_frame;
+	dst_q = &ctx->q_stream;
+
+	/*
+	 * There has to be at least one buffer queued on each queued_list, which
+	 * means either in driver already or waiting for driver to claim it
+	 * and start processing.
+	 */
+	if ((!src_q->streaming || list_empty(&src_q->queued_list)) &&
+	    (!dst_q->streaming || list_empty(&dst_q->queued_list))) {
+		rc |= POLLERR;
+		goto end;
+	}
+
+	spin_lock_irqsave(&src_q->done_lock, flags);
+	if (list_empty(&src_q->done_list))
+		poll_wait(file, &src_q->done_wq, wait);
+	spin_unlock_irqrestore(&src_q->done_lock, flags);
+
+	spin_lock_irqsave(&dst_q->done_lock, flags);
+	if (list_empty(&dst_q->done_list)) {
+		/*
+		 * If the last buffer was dequeued from the capture queue,
+		 * return immediately. DQBUF will return -EPIPE.
+		 */
+		if (dst_q->last_buffer_dequeued) {
+			spin_unlock_irqrestore(&dst_q->done_lock, flags);
+			rc |= POLLIN | POLLRDNORM;
+			goto end;
+		}
+
+		poll_wait(file, &dst_q->done_wq, wait);
+	}
+	spin_unlock_irqrestore(&dst_q->done_lock, flags);
+
+	spin_lock_irqsave(&src_q->done_lock, flags);
+	if (!list_empty(&src_q->done_list))
+		src_vb = list_first_entry(&src_q->done_list, struct vb2_buffer,
+					  done_entry);
+	if (src_vb && (src_vb->state == VB2_BUF_STATE_DONE ||
+		       src_vb->state == VB2_BUF_STATE_ERROR))
+		rc |= POLLOUT | POLLWRNORM;
+	spin_unlock_irqrestore(&src_q->done_lock, flags);
+
+	spin_lock_irqsave(&dst_q->done_lock, flags);
+	if (!list_empty(&dst_q->done_list))
+		dst_vb = list_first_entry(&dst_q->done_list, struct vb2_buffer,
+					  done_entry);
+	if (dst_vb && (dst_vb->state == VB2_BUF_STATE_DONE ||
+		       dst_vb->state == VB2_BUF_STATE_ERROR))
+		rc |= POLLIN | POLLRDNORM;
+	spin_unlock_irqrestore(&dst_q->done_lock, flags);
+
+end:
+	mutex_unlock(&hva->lock);
+	return rc;
+}
+
+/* v4l2 ops */
+static const struct v4l2_file_operations hva_fops = {
+	.owner			= THIS_MODULE,
+	.open			= hva_open,
+	.release		= hva_release,
+	.unlocked_ioctl		= video_ioctl2,
+	.mmap			= hva_mmap,
+	.poll			= hva_poll,
+};
+
+/* v4l2 ioctl ops */
+static const struct v4l2_ioctl_ops hva_ioctl_ops = {
+	.vidioc_querycap		= hva_querycap,
+	.vidioc_enum_fmt_vid_cap	= hva_enum_fmt_stream,
+	.vidioc_enum_fmt_vid_out	= hva_enum_fmt_frame,
+	.vidioc_g_fmt_vid_cap		= hva_g_fmt_stream,
+	.vidioc_g_fmt_vid_out		= hva_g_fmt_frame,
+	.vidioc_try_fmt_vid_cap		= hva_try_fmt_stream,
+	.vidioc_try_fmt_vid_out		= hva_try_fmt_frame,
+	.vidioc_s_fmt_vid_cap		= hva_s_fmt_stream,
+	.vidioc_s_fmt_vid_out		= hva_s_fmt_frame,
+	.vidioc_g_parm			= hva_g_parm,
+	.vidioc_s_parm			= hva_s_parm,
+	.vidioc_reqbufs			= hva_reqbufs,
+	.vidioc_create_bufs             = hva_create_bufs,
+	.vidioc_querybuf		= hva_querybuf,
+	.vidioc_expbuf			= hva_expbuf,
+	.vidioc_qbuf			= hva_qbuf,
+	.vidioc_dqbuf			= hva_dqbuf,
+	.vidioc_streamon		= hva_streamon,
+	.vidioc_streamoff		= hva_streamoff,
+	.vidioc_g_selection		= hva_g_selection,
+	.vidioc_s_selection		= hva_s_selection,
+	.vidioc_subscribe_event		= v4l2_ctrl_subscribe_event,
+	.vidioc_unsubscribe_event	= v4l2_event_unsubscribe,
+};
+
+static int hva_probe(struct platform_device *pdev)
+{
+	struct hva_device *hva;
+	struct device *dev = &pdev->dev;
+	struct video_device *vdev;
+	int ret;
+
+	hva = devm_kzalloc(dev, sizeof(*hva), GFP_KERNEL);
+	if (!hva) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	hva->dev = dev;
+	hva->pdev = pdev;
+	platform_set_drvdata(pdev, hva);
+
+	mutex_init(&hva->lock);
+
+	/* probe hardware */
+	ret = hva_hw_probe(pdev, hva);
+	if (ret)
+		goto err;
+
+	/* register all available encoders */
+	register_all(hva);
+
+	/* register on V4L2 */
+	ret = v4l2_device_register(dev, &hva->v4l2_dev);
+	if (ret) {
+		dev_err(dev, "%s %s could not register v4l2 device\n",
+			HVA_PREFIX, HVA_NAME);
+		goto err_hw_remove;
+	}
+
+	/* continuous memory allocator */
+	hva->alloc_ctx = vb2_dma_contig_init_ctx(dev);
+	if (IS_ERR(hva->alloc_ctx)) {
+		ret = PTR_ERR(hva->alloc_ctx);
+		goto err_v4l2;
+	}
+
+	vdev = video_device_alloc();
+	vdev->fops = &hva_fops;
+	vdev->ioctl_ops = &hva_ioctl_ops;
+	vdev->release = video_device_release;
+	vdev->lock = &hva->lock;
+	vdev->v4l2_dev = &hva->v4l2_dev;
+	snprintf(vdev->name, sizeof(vdev->name), "%s", HVA_NAME);
+	vdev->vfl_dir = VFL_DIR_M2M;
+	ret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);
+	if (ret) {
+		dev_err(dev, "%s %s failed to register video device\n",
+			HVA_PREFIX, HVA_NAME);
+		goto err_vdev_release;
+	}
+
+	hva->vdev = vdev;
+	video_set_drvdata(vdev, hva);
+
+	dev_info(dev, "%s %s registered as /dev/video%d\n", HVA_PREFIX,
+		 HVA_NAME, vdev->num);
+
+	dev_info(dev, "%s %s esram reserved for address: 0x%x size:%d\n",
+		 HVA_PREFIX, HVA_NAME, hva->esram_addr,
+		 hva->esram_size);
+
+	return 0;
+
+err_vdev_release:
+	video_device_release(vdev);
+	vb2_dma_contig_cleanup_ctx(hva->alloc_ctx);
+err_v4l2:
+	v4l2_device_unregister(&hva->v4l2_dev);
+err_hw_remove:
+	hva_hw_remove(hva);
+err:
+	return ret;
+}
+
+static int hva_remove(struct platform_device *pdev)
+{
+	struct hva_device *hva = platform_get_drvdata(pdev);
+	struct device *dev = hva_to_dev(hva);
+
+	dev_info(dev, "%s removing %s\n", HVA_PREFIX, pdev->name);
+
+	hva_hw_remove(hva);
+
+	vb2_dma_contig_cleanup_ctx(hva->alloc_ctx);
+
+	video_unregister_device(hva->vdev);
+
+	v4l2_device_unregister(&hva->v4l2_dev);
+
+	return 0;
+}
+
+static const struct dev_pm_ops hva_pm_ops = {
+	.runtime_suspend	= hva_hw_runtime_suspend,
+	.runtime_resume		= hva_hw_runtime_resume,
+};
+
+static const struct of_device_id hva_match_types[] = {
+	{
+	 .compatible = "st,sti-hva",
+	},
+	{ /* end node */ }
+};
+
+MODULE_DEVICE_TABLE(of, hva_match_types);
+
+struct platform_driver hva_driver = {
+	.probe  = hva_probe,
+	.remove = hva_remove,
+	.driver = {
+		.name           = HVA_NAME,
+		.owner          = THIS_MODULE,
+		.of_match_table = hva_match_types,
+		.pm             = &hva_pm_ops,
+		},
+};
+
+module_platform_driver(hva_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Yannick Fertre <yannick.fertre@st.com>");
+MODULE_DESCRIPTION("HVA video encoder V4L2 driver");
diff --git a/drivers/media/platform/sti/hva/hva.h b/drivers/media/platform/sti/hva/hva.h
new file mode 100644
index 0000000..402a580
--- /dev/null
+++ b/drivers/media/platform/sti/hva/hva.h
@@ -0,0 +1,454 @@
+/*
+ * Copyright (C) STMicroelectronics SA 2015
+ * Authors: Yannick Fertre <yannick.fertre@st.com>
+ *          Hugues Fruchet <hugues.fruchet@st.com>
+ * License terms:  GNU General Public License (GPL), version 2
+ */
+
+#ifndef HVA_H
+#define HVA_H
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/videobuf2-v4l2.h>
+
+#define get_queue(c, t) (t == V4L2_BUF_TYPE_VIDEO_OUTPUT ? \
+			 &c->q_frame : &c->q_stream)
+
+#define to_type_str(type) (type == V4L2_BUF_TYPE_VIDEO_OUTPUT ? \
+			   "frame" : "stream")
+
+#define fh_to_ctx(f)    (container_of(f, struct hva_ctx, fh))
+
+#define hva_to_dev(h)   (h->dev)
+
+#define ctx_to_dev(c)   (c->hva_dev->dev)
+
+#define ctx_to_hdev(c)  (c->hva_dev)
+
+#define ctx_to_enc(c)   (c->encoder)
+
+#define HVA_PREFIX "[---:----]"
+
+#define MAX_CONTEXT 16
+
+extern const struct hva_encoder nv12h264enc;
+extern const struct hva_encoder nv21h264enc;
+
+/**
+ * struct hva_frame_fmt - driver's internal color format data
+ *
+ * @pixelformat: fourcc code for uncompressed video format
+ * @nb_planes:   number of planes (e.g. [0]=RGB/Y - [1]=Cb/Cr - ...)
+ * @bpp:         bits per pixel (general)
+ * @bpp_plane0:  byte per pixel for the 1st plane
+ * @w_align:     width alignment in pixel (multiple of)
+ * @h_align:     height alignment in pixel (multiple of)
+ */
+struct hva_frame_fmt {
+	u32	pixelformat;
+	u8	nb_planes;
+	u8	bpp;
+	u8	bpp_plane0;
+	u8	w_align;
+	u8	h_align;
+};
+
+/**
+ * struct hva_frameinfo - information about hva frame
+ *
+ * @flags:        flags about frame
+ * @fmt:          format of frame
+ * @width:        width of frame
+ * @height:       height of frame
+ * @crop:         cropping window due to encoder alignment constraints
+ *                (1920x1080@0,0 inside 1920x1088 encoded frame for ex.)
+ * @pixelaspect:  pixel aspect ratio of video (4/3, 5/4)
+ * @frame_width:  width of frame (encoder alignment constraint)
+ * @frame_height: height of frame (encoder alignment constraint)
+*/
+struct hva_frameinfo {
+	u32			flags;
+	struct hva_frame_fmt	fmt;
+	u32			width;
+	u32			height;
+	struct v4l2_rect	crop;
+	struct v4l2_fract	pixelaspect;
+	u32			frame_width;
+	u32			frame_height;
+};
+
+#define HVA_FRAMEINFO_FLAG_CROP		0x0001
+#define HVA_FRAMEINFO_FLAG_PIXELASPECT	0x0002
+
+/**
+ * struct hva_streaminfo - information about hva stream
+ *
+ * @flags         flags about stream
+ * @streamformat: fourcc code of compressed video format (H.264...)
+ * @width:        width of stream
+ * @height:       height of stream
+ * @dpb:          number of frames needed to encode a single frame
+ *                (e.g. H.264 dpb up to 16 in standard)
+ * @profile:      profile string
+ * @level:        level string
+ * @other:        other string information from codec
+ */
+struct hva_streaminfo {
+	u32	flags;
+	u32	streamformat;
+	u32	width;
+	u32	height;
+	u32	dpb;
+	u8	profile[32];
+	u8	level[32];
+	u8	other[32];
+};
+
+#define HVA_STREAMINFO_FLAG_OTHER	0x0001
+#define HVA_STREAMINFO_FLAG_H264	0x0002
+#define HVA_STREAMINFO_FLAG_VP8		0x0004
+
+/**
+ * struct hva_controls - hva controls set
+ *
+ * @bitrate_mode:  bitrate mode (constant bitrate or variable bitrate)
+ * @gop_size:      groupe of picture size
+ * @bitrate:       bitrate (in kbps)
+ * @aspect:        video aspect
+ * @profile:       H.264 profile
+ * @level:         H.264 level
+ * @entropy_mode:  H.264 entropy mode (CABAC or CVLC)
+ * @cpb_size:      coded picture buffer size (in kbps)
+ * @dct8x8:        transform mode 8x8 enable
+ * @qpmin:         minimum quantizer
+ * @qpmax:         maximum quantizer
+ * @vui_sar:       pixel aspect ratio enable
+ * @vui_sar_idc:   pixel aspect ratio identifier
+ * @sei_fp:        sei frame packing arrangement enable
+ * @sei_fp_type:   sei frame packing arrangement type
+ */
+struct hva_controls {
+	enum v4l2_mpeg_video_bitrate_mode			bitrate_mode;
+	u32							gop_size;
+	u32							bitrate;
+	enum v4l2_mpeg_video_aspect				aspect;
+	enum v4l2_mpeg_video_h264_profile			profile;
+	enum v4l2_mpeg_video_h264_level				level;
+	enum v4l2_mpeg_video_h264_entropy_mode			entropy_mode;
+	u32							cpb_size;
+	bool							dct8x8;
+	u32							qpmin;
+	u32							qpmax;
+	bool							vui_sar;
+	enum v4l2_mpeg_video_h264_vui_sar_idc			vui_sar_idc;
+	bool							sei_fp;
+	enum v4l2_mpeg_video_h264_sei_fp_arrangement_type	sei_fp_type;
+};
+
+/**
+ * struct hva_frame - hva frame
+ *
+ * @v4l2:     video buffer information for v4l2.
+ *            To be kept first and not to be wrote by driver.
+ *            Allows to get the hva_frame fields by just casting a vb2_buffer
+ *            with hva_frame struct. This is allowed through the use of
+ *            vb2 custom buffer mechanism, see @buf_struct_size of
+ *            struct vb2_queue in include/media/videobuf2-core.h
+ * @paddr:    physical address (for hardware)
+ * @vaddr:    virtual address (kernel can read/write)
+ * @prepared: true if vaddr/paddr are resolved
+ */
+struct hva_frame {
+	struct vb2_v4l2_buffer	v4l2;
+	dma_addr_t		paddr;
+	void			*vaddr;
+	bool			prepared;
+};
+
+/**
+ * struct hva_stream - hva stream
+ *
+ * @v4l2:     video buffer information for v4l2.
+ *            To be kept first and not to be wrote by driver.
+ *            Allows to get the hva_stream fields by just casting a vb2_buffer
+ *            with hva_stream struct. This is allowed through the use of
+ *            vb2 custom buffer mechanism, see @buf_struct_size of
+ *            struct vb2_queue in include/media/videobuf2-core.h
+ * @list:     list element
+ * @paddr:    physical address (for hardware)
+ * @vaddr:    virtual address (kernel can read/write)
+ * @prepared: true if vaddr/paddr are resolved
+ * @payload:  number of bytes occupied by data in the buffer
+ */
+struct hva_stream {
+	struct vb2_v4l2_buffer	v4l2;
+	struct list_head	list;
+	dma_addr_t		paddr;
+	void			*vaddr;
+	int			prepared;
+	unsigned int		payload;
+};
+
+/**
+ * struct hva_buffer - hva buffer
+ *
+ * @name:  name of requester
+ * @attrs: dma attributes
+ * @paddr: physical address (for hardware)
+ * @vaddr: virtual address (kernel can read/write)
+ * @size:  size of buffer
+ */
+struct hva_buffer {
+	const char		*name;
+	struct dma_attrs	attrs;
+	dma_addr_t		paddr;
+	void			*vaddr;
+	u32			size;
+};
+
+struct hva_device;
+struct hva_encoder;
+
+/**
+ * struct hva_ctx - hva context
+ *
+ * @flags:          validity of streaminfo and frameinfo fields
+ * @fh:             v4l2 file handle
+ * @hva_dev:        the device this context applies to
+ * @client_id:      client identifier
+ * @q_frame:        v4l2 vb2 queue for frames, allocated by driver
+ *                  but managed by vb2 framework
+ * @q_stream:       v4l2 vb2 queue for streams, allocated by driver
+ *                  but managed by vb2 framework
+ * @name:           instance name (debug purpose)
+ * @list_stream:    list of streams queued
+ * @frame_num:      frame number
+ * @stream_num:     stream number
+ * @ctrl_handler:   v4l2 controls handler
+ * @ctrls:          hva controls set
+ * @time_per_frame: time per frame
+ * @streaminfo:     stream properties
+ * @frameinfo:      frame properties
+ * @encoder:        current encoder
+ * @num_frames:     number of frames received
+ * @num_streams:    number of streams produced
+ * @priv:           private codec context for this instance, allocated
+ *                  by encoder @open time.
+ * @sys_errors:     number of system errors (memory, resource, pm..)
+ * @encode_errors:  number of encoding errors (hw/driver errors)
+ * @frame_errors:   number of frame errors (format, size, header...)
+ * @hw_err:         true if hardware error detected
+ * @task:           hardware task descriptor
+ */
+struct hva_ctx {
+	u32				flags;
+	struct v4l2_fh			fh;
+	struct hva_device		*hva_dev;
+	u8				client_id;
+	struct vb2_queue		q_frame;
+	struct vb2_queue		q_stream;
+	char				name[100];
+	struct list_head		list_stream;
+	u32				frame_num;
+	u32				stream_num;
+	struct v4l2_ctrl_handler	ctrl_handler;
+	struct hva_controls		ctrls;
+	struct v4l2_fract		time_per_frame;
+	struct hva_streaminfo		streaminfo;
+	struct hva_frameinfo		frameinfo;
+	struct hva_encoder		*encoder;
+	u32				num_frames;
+	u32				num_streams;
+	void				*priv;
+	u32				sys_errors;
+	u32				encode_errors;
+	u32				frame_errors;
+	bool				hw_err;
+	struct hva_buffer		*task;
+};
+
+#define HVA_FLAG_STREAMINFO 0x0001
+#define HVA_FLAG_FRAMEINFO 0x0002
+
+#define HVA_MAX_ENCODERS 30
+
+/**
+ * struct hva_device - abstraction for hva entity
+ *
+ * @v4l2_dev:        v4l2 device
+ * @vdev:            video device
+ * @pdev:            platform device
+ * @dev:             device
+ * @lock:            mutex used for critical sections & v4l2 ops serialization
+ * @instance_id:     instance identifier
+ * @alloc_ctx:       videobuf2 memory allocator context
+ * @contexts_list:   contexts list
+ * @regs:            register io memory access
+ * @regs_size:       register size
+ * @irq_its:         its interruption
+ * @irq_err:         error interruption
+ * @chip_id:         chipset identifier
+ * @protect_mutex:   mutex used to lock access of hardware
+ * @interrupt:       completion interrupt
+ * @clk:             hva clock
+ * @esram_addr:      esram address
+ * @esram_size:      esram size
+ * @sfl_reg:         status fifo level register value
+ * @sts_reg:         status register value
+ * @lmi_err_reg:     local memory interface error register value
+ * @emi_err_reg:     external memory interface error register value
+ * @hec_mif_err_reg: HEC memory interface error register value
+ * @encoders:        list of all encoders registered
+ * @nb_of_encoders:  number of encoders registered
+ * @nb_of_instances: number of instance
+ */
+struct hva_device {
+	struct v4l2_device		v4l2_dev;
+	struct video_device		*vdev;
+	struct platform_device		*pdev;
+	struct device			*dev;
+	/* mutex used for critical sections & v4l2 ops serialization */
+	struct mutex			lock;
+	int				instance_id;
+	struct vb2_alloc_ctx		*alloc_ctx;
+	struct hva_ctx			*contexts_list[MAX_CONTEXT];
+	void __iomem			*regs;
+	int				regs_size;
+	int				irq_its;
+	int				irq_err;
+	unsigned long int		chip_id;
+	/* mutex used to lock access of hardware */
+	struct mutex			protect_mutex;
+	struct completion		interrupt;
+	struct clk			*clk;
+	u32				esram_addr;
+	u32				esram_size;
+	u32				sfl_reg;
+	u32				sts_reg;
+	u32				lmi_err_reg;
+	u32				emi_err_reg;
+	u32				hec_mif_err_reg;
+	const struct hva_encoder	*encoders[HVA_MAX_ENCODERS];
+	u32				nb_of_encoders;
+	u32				nb_of_instances;
+};
+
+/**
+ * struct hva_encoder - hva encoder
+ *
+ * @name: encoder name
+ * @streamformat: fourcc code for compressed video format (H.264...)
+ * @pixelformat: fourcc code for uncompressed video format
+ * @max_width: maximum width of frame for this encoder
+ * @max_height: maximum height of frame for this encoder
+ * @open: open encoder
+ * @close: close encoder
+ * @encode: encode a frame (struct hva_frame) in a stream (struct hva_stream)
+ */
+
+struct hva_encoder {
+	const char *name;
+	u32 streamformat;
+	u32 pixelformat;
+	u32 max_width;
+	u32 max_height;
+	int (*open)(struct hva_ctx *ctx);
+	int (*close)(struct hva_ctx *ctx);
+	int (*encode)(struct hva_ctx *ctx, struct hva_frame *frame,
+		      struct hva_stream *stream);
+};
+
+static inline const char *profile_str(unsigned int p)
+{
+	switch (p) {
+	case V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:
+		return "baseline profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:
+		return "main profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED:
+		return "extended profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:
+		return "high profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10:
+		return "high 10 profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422:
+		return "high 422 profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE:
+		return "high 444 predictive profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_10_INTRA:
+		return "high 10 intra profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_422_INTRA:
+		return "high 422 intra profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_INTRA:
+		return "high 444 intra profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_CAVLC_444_INTRA:
+		return "calvc 444 intra profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_BASELINE:
+		return "scalable baseline profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH:
+		return "scalable high profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_SCALABLE_HIGH_INTRA:
+		return "scalable high intra profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_STEREO_HIGH:
+		return "stereo high profile";
+	case V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH:
+		return "multiview high profile";
+	default:
+		return "unknown profile";
+	}
+}
+
+static inline const char *level_str(enum v4l2_mpeg_video_h264_level l)
+{
+	switch (l) {
+	case V4L2_MPEG_VIDEO_H264_LEVEL_1_0:
+		return "level 1.0";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_1B:
+		return "level 1b";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_1_1:
+		return "level 1.1";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_1_2:
+		return "level 1.2";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_1_3:
+		return "level 1.3";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_2_0:
+		return "level 2.0";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_2_1:
+		return "level 2.1";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_2_2:
+		return "level 2.2";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_3_0:
+		return "level 3.0";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_3_1:
+		return "level 3.1";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_3_2:
+		return "level 3.2";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_4_0:
+		return "level 4.0";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_4_1:
+		return "level 4.1";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_4_2:
+		return "level 4.2";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_5_0:
+		return "level 5.0";
+	case V4L2_MPEG_VIDEO_H264_LEVEL_5_1:
+		return "level 5.1";
+	default:
+		return "unknown level";
+	}
+}
+
+static inline const char *bitrate_mode_str(enum v4l2_mpeg_video_bitrate_mode m)
+{
+	switch (m) {
+	case V4L2_MPEG_VIDEO_BITRATE_MODE_VBR:
+		return "variable bitrate";
+	case V4L2_MPEG_VIDEO_BITRATE_MODE_CBR:
+		return "constant bitrate";
+	default:
+		return "unknown bitrate mode";
+	}
+}
+
+#endif /* HVA_H */
-- 
1.9.1

